<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Go语言中 new()和make()的区别详解</title>
      <link href="/2018/10/06/sync.WaitGroup%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <content type="html"><![CDATA[<p>#概述<br>Go语言中的new和make 一直是新手比较容易混淆的东西，咋一看很相似，接下来我们来分析两者的区别</p><p>#new的主要特性</p><p>首先new是内建函数，你可以从  <a href="http://golang.org/pkg/builtin/#new" target="_blank" rel="noopener">http://golang.org/pkg/builtin/#new</a>  这儿看到它，它的定义也很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码如下：</span><br><span class="line">func new(Type) *Type</span><br></pre></td></tr></table></figure><p>官方文档对于它的描述是：</p><p>内建函数new用来分配内存，它的第一个参数是类型，不是一个值，它的返回值是一个指向新分配类型零值的指针</p><p>根据这段描述，我们可以自己实现一个类似的new的功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代码如下：</span><br><span class="line">func newInt() *Int&#123;</span><br><span class="line">var i int</span><br><span class="line">return &amp;i</span><br><span class="line">&#125;</span><br><span class="line">someint :=newInt()</span><br></pre></td></tr></table></figure></p><p>这个函数的功能跟 someInt :=new(int) 一摸一样，所以在我们自定义new开头的函数时，出于约定应该返回类型的指针。</p><p>#make的主要特性</p><p>make也是内建函数，你可以从<a href="http://golang.org/pkg/builtin/#make" target="_blank" rel="noopener">http://golang.org/pkg/builtin/#make</a> 这儿看到它，它的定义比 new 多了一个参数，返回值也不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码如下：</span><br><span class="line">func make(Type,size INtergerType)Type</span><br></pre></td></tr></table></figure><p>官方文档对于它的描述是：</p><p>内建函数make用来为slie ，map 或 chan 类型分配内存和初始化一个对象(注意：只能用在这三种类型上)，跟new类似，第一个参数也是一个类型而不是一个值，<br>跟new不同的是，make返回的类型的引用而不是指针，而返回值也依赖于具体传入的类型，具体说明如下：</p><p>代码如下：</p><p>Slice ：第二个参数size指定了它的长度，它的容易和长度相同。<br>你可以传入第三个参数来指定不同的容量值，但必须不能长度值小。<br>比如 make([]int,0,10)<br>Map:根据size大小来初始化分配内存，不过分配后的map长度为0，如果size被忽略了，那么会在初始化分配内存时分配一个小尺寸的内存<br>Channel：管道缓冲区依据缓冲区容量被初始化。如果容量为0或者忽略容量。管道是没有缓冲区的</p><p>总结</p><p>new 的作用是初始化一个指向类型的指针(*T)，make 的作用是为 slice，map 或 chan 初始化并返回引用(T)。</p>]]></content>
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go sync包 WaitGroup使用</title>
      <link href="/2018/10/05/sync.WaitGroup%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <content type="html"><![CDATA[<p>sync.WaitGroup用途：<br>它能够一直等到所有的goroutine执行完成，<br>并且阻塞主线程的执行，直到所有的goroutine执行完成<br>注意：它们的执行结果有没有顺序的，调度器不能保证多个goroutine执行次序，且进程退出时不会等待它们结束。</p><p>waiGroup共有三个方法：Add(delta int)Done()Wait()<br>Add:添加或者减少等待goroutine的数量<br>Done：相当于Add(-1)<br>Wait:执行阻塞，知道直到所有的WaitGroutine数量变成0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">for i := 0; i &gt; 5; i = i + 1 &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func(n int) &#123;</span><br><span class="line">defer wg.Add(-1)</span><br><span class="line">EchoNumber(n)</span><br><span class="line"></span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">func EchoNumber(i int) &#123;</span><br><span class="line">time.Sleep(3e9)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>golang中的同步是通过sync.WaitGroup来实现的，<br>WaitGroup的功能：它实现了一个类似队列的结构，<br>可以一直向队列添加任务，当任务完成后便从队列中删除，<br>如果队列中的任务没有完全完成，可以通过Wait()函数来出发阻塞，<br>防止程序继续进行，直到所有的队列任务都完成为止。<br>WaitGroup的特点是Wait()可以用来阻塞直到队列中的所有任务都完成才解除阻塞，<br>而不需要Sleep一个固定的时间来等待，但是其缺点是无法指定固定的goroutine数目，<br>可能通过使用channel解决此问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var waitgroup sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func Afunction(shownum int) &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(shownum)</span><br><span class="line">//任务队列，将任务队列中的任务数量-1，其实.Done就是.Add(-1)</span><br><span class="line">waitgroup.Done()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">//每创建一个goroutine，就把任务队列中的任务的数量+1</span><br><span class="line">waitgroup.Add(1)</span><br><span class="line">go Afunction(i)</span><br><span class="line">&#125;</span><br><span class="line">//.Wait()这里发生阻塞，直到队列中所有的任务结束就会解除阻塞</span><br><span class="line">waitgroup.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android studio升级之后很多jar无法下载 解决</title>
      <link href="/2018/09/08/android%20studio%E5%8D%87%E7%BA%A7%E4%B9%8B%E5%90%8E%E5%BE%88%E5%A4%9Ajar%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%20%E8%A7%A3%E5%86%B3/"/>
      <content type="html"><![CDATA[<p>解决方案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    </span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven&#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.2.1&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven&#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> android studio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac android studio 无线调试</title>
      <link href="/2018/09/05/mac%20android%20studio%20%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/"/>
      <content type="html"><![CDATA[<p>1.打开Android studio 的 如下图：<br><img src="/2018/09/05/mac android studio 无线调试/../../../../images/20190410211814.png" alt="Alt text"><br>1.点开{1}Plugins.在{2}输入 wifi adb ultimate  点击{3}蓝色的英文字符会弹出一个框。点击{4}会提示重新启动ndroid  studio，点击重新启动就好。<br>2.重新打开Android studio后  将手机数据连接笔记本电脑如下图：如果无法设备，点击刷新稍等片刻。<br><img src="/2018/09/05/mac android studio 无线调试/../../../../images/20190410212244.png" alt="Alt text"><br>3.点击运行后，拔掉数据线即可无线调试了。我没有拔掉数据线所以在 Select Deployment Tagrget 有两处选择。<br><img src="/2018/09/05/mac android studio 无线调试/../../../../images/20190410212649.png" alt="Alt text"></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flutter Widget 之旅</title>
      <link href="/2018/03/05/Flutter%20Widget%20%E4%B9%8B%E6%97%85/"/>
      <content type="html"><![CDATA[<p>flutter 程序入口 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    new Center(</span><br><span class="line">      child: new Text(</span><br><span class="line">        &apos;Hello, world!&apos;,</span><br><span class="line">        textDirection: TextDirection.ltr,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基本的小部件：<br>    1.Text：在应用程序中可以构建一个文本信息展示<br>    2.Row、Cloumn：水平布局(Row)与垂直布局(Column)方向上创建灵活的布局。其设计基于网络的Flexbox布局模型。<br>    3.Stack：绘制顺序上堆叠小部件(类似 android RelativeLayout),您可以根据Positioned在子布局使用该小部件 , Stack相对于堆栈的顶部 , 右侧 , 底部或左侧边缘定位他们。堆栈基于Web的绝对定位布局模型。<br>    4.Container：创建矩形视觉元素。一个容器可以装饰一个 BoxDecoration , 如背景 ,边框或阴影。也可以具有边距 , 填充 和 应用于其大小的约束。也可以矩阵在三维空间进行变换<br>    5.Scaffold：实现了基本的纸墨设计布局结构。MaterialApp的child是Scaffold Widget。支持 左边栏(Drawers) , snack bars , 以及bottom sheets。<br>    Scaffold 有下面几个主要属性：<br>    appBar：显示在界面顶部的一个AppBar,也就是android中的ActionBar、Toolbar<br>    body：当前界面所显示的主要内容Widget<br>    floatingActionButton：纸墨设计中所定义的FAB,界面的主要功能按钮<br>    persistentFooterButtons：固定在下方显示的按钮,比如对话框下方的确定、取消按钮<br>    drawer：侧边栏控件<br>    backgroundColor：内容的背景颜色,模拟热使用的是ThemeData.scaffoldBackgroundColor的值<br>    bottomNavigationBar：类似于android重的android:windowSoftInputMode=”adjustResize”控制界面内容 body 是否重新布局来避免底部被覆盖了，比如当键盘显示的时候，重新布局避免被键盘盖住内容。默认值为 true。<br>显示 snackbar 或者 bottom sheet 的时候，需要使用当前的 BuildContext 参数调用 Scaffold.of 函数来获取 ScaffoldState 对象，然后使用 ScaffoldState.showSnackBar 和 ScaffoldState.showBottomSheet 函数来显示。</p><p>主要的小部件：</p><pre><code>1.StatelessWidget[无状态]2.StatefulWidget[有状态]</code></pre>]]></content>
      
      <categories>
          
          <category> flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android webView独立进程详解</title>
      <link href="/2017/12/15/android%20webView%E7%8B%AC%E7%AB%8B%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <content type="html"><![CDATA[<p> WebView独立进程的好处</p><p>1.有效增大App的运存，减少由webview引起的内存泄露对主进程内存的占用。<br>2.避免WebView的Crash影响App主进程的运行。<br>3.拥有对WebView独立进程操控权。<br>WebView进程与其他进程通讯的方式<br>把webview独立进程之后会发现，埋点功能和接收主进程数据都不正常了，这里就涉及到进程间通讯的问题了;<br>进程通讯无非就是那几种，aidl，messager，content provider，广播;</p><a id="more"></a> <p>webview的配置</p><p>//声明WebSettings子类<br>WebSettings webSettings = webView.getSettings();</p><p>//如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript<br>webSettings.setJavaScriptEnabled(true);  </p><p>//支持插件<br>webSettings.setPluginsEnabled(true); </p><p>//设置自适应屏幕，两者合用<br>webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小<br>webSettings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小</p><p>//缩放操作<br>webSettings.setSupportZoom(true); //支持缩放，默认为true。是下面那个的前提。<br>webSettings.setBuiltInZoomControls(true); //设置内置的缩放控件。若为false，则该WebView不可缩放<br>webSettings.setDisplayZoomControls(false); //隐藏原生的缩放控件</p><p>//其他细节操作<br>webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //关闭webview中缓存<br>webSettings.setAllowFileAccess(true); //设置可以访问文件<br>webSettings.setJavaScriptCanOpenWindowsAutomatically(true); //支持通过JS打开新窗口<br>webSettings.setLoadsImagesAutomatically(true); //支持自动加载图片<br>webSettings.setDefaultTextEncodingName(“utf-8”);//设置编码格式</p><p>常见用法：设置WebView缓存</p><p>当加载 html 页面时，WebView会在/data/data/包名目录下生成 database 与 cache 两个文件夹<br>请求的 URL记录保存在 WebViewCache.db，而 URL的内容是保存在 WebViewCache 文件夹下<br>是否启用缓存：</p><p> //优先使用缓存:<br>    WebView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);<br>        //缓存模式如下：<br>        //LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据<br>        //LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。<br>        //LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.<br>        //LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。</p><p> //不使用缓存:<br> WebView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);</p><p> 结合使用（离线加载）</p><p> if (NetStatusUtil.isConnected(getApplicationContext())) {<br>    webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);//根据cache-control决定是否从网络上取数据。<br>} else {<br>    webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);//没网，则从本地获取，即离线加载<br>}</p><p>webSettings.setDomStorageEnabled(true); // 开启 DOM storage API 功能<br>webSettings.setDatabaseEnabled(true);   //开启 database storage API 功能<br>webSettings.setAppCacheEnabled(true);//开启 Application Caches 功能</p><p>String cacheDirPath = getFilesDir().getAbsolutePath() + APP_CACAHE_DIRNAME;<br>webSettings.setAppCachePath(cacheDirPath); //设置  Application Caches 缓存目录</p><p>1.1 WebView的状态</p><p> //激活WebView为活跃状态，能正常执行网页的响应<br>webView.onResume() ；</p><p>//当页面被失去焦点被切换到后台不可见状态，需要执行onPause<br>//通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。<br>webView.onPause()；</p><p>//当应用程序(存在webview)被切换到后台时，这个方法不仅仅针对当前的webview而是全局的全应用程序的webview<br>//它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。<br>webView.pauseTimers()<br>//恢复pauseTimers状态<br>webView.resumeTimers()；</p><p>//销毁Webview<br>//在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview<br>//但是注意：webview调用destory时,webview仍绑定在Activity上<br>//这是由于自定义webview构建时传入了该Activity的context对象<br>//因此需要先从父容器中移除webview,然后再销毁webview:<br>rootLayout.removeView(webView);<br>webView.destroy();</p><p>1.2 关于前进 / 后退网页</p><p>//是否可以后退<br>Webview.canGoBack()<br>//后退网页<br>Webview.goBack()</p><p>//是否可以前进<br>Webview.canGoForward()<br>//前进网页<br>Webview.goForward()</p><p>//以当前的index为起始点前进或者后退到历史记录中指定的steps<br>//如果steps为负数则为后退，正数则为前进<br>Webview.goBackOrForward(intsteps) </p><p>常见用法：Back键控制网页后退</p><p>问题：在不做任何处理前提下 ，浏览网页时点击系统的“Back”键,整个 Browser 会调用 finish()而结束自身<br>目标：点击返回后，是网页回退而不是推出浏览器<br>解决方案：在当前Activity中处理并消费掉该 Back 事件</p><p>public boolean onKeyDown(int keyCode, KeyEvent event) {<br>    if ((keyCode == KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) {<br>        mWebView.goBack();<br>        return true;<br>    }<br>    return super.onKeyDown(keyCode, event);<br>}</p><p>1.3 清除缓存数据</p><p>//清除网页访问留下的缓存<br>//由于内核缓存是全局的因此这个方法不仅仅针对webview而是针对整个应用程序.<br>Webview.clearCache(true);</p><p>//清除当前webview访问的历史记录<br>//只会webview访问历史记录里的所有记录除了当前访问记录<br>Webview.clearHistory()；</p><p>//这个api仅仅清除自动完成填充的表单数据，并不会清除WebView存储到本地的数据<br>Webview.clearFormData()；</p><p>1.4 WebViewClient类</p><p>作用：处理各种通知 &amp; 请求事件<br>常见方法：<br>常见方法1：shouldOverrideUrlLoading()</p><p>作用：打开网页时不调用系统浏览器， 而是在本WebView中显示；在网页上的所有加载都经过这个方法,这个函数我们可以做很多操作。<br>//步骤1. 定义Webview组件<br>Webview webview = (WebView) findViewById(R.id.webView1);</p><p>//步骤2. 选择加载方式<br>  //方式1. 加载一个网页：<br>  webView.loadUrl(“<a href="http://www.google.com/" target="_blank" rel="noopener">http://www.google.com/</a>“);</p><p>  //方式2：加载apk包中的html页面<br>  webView.loadUrl(“file:///android_asset/test.html”);</p><p>  //方式3：加载手机本地的html页面<br>   webView.loadUrl(“content://com.android.htmlfileprovider/sdcard/test.html”);</p><p>//步骤3. 复写shouldOverrideUrlLoading()方法，使得打开网页时不调用系统浏览器， 而是在本WebView中显示<br>    webView.setWebViewClient(new WebViewClient(){<br>      @Override<br>      public boolean shouldOverrideUrlLoading(WebView view, String url) {<br>          view.loadUrl(url);<br>      return true;<br>      }<br>  });</p><p>常见方法2：onPageStarted()</p><p>作用：开始载入页面调用的，我们可以设定一个loading的页面，告诉用户程序在等待网络响应。<br> webView.setWebViewClient(new WebViewClient(){<br>      @Override<br>      public void  onPageStarted(WebView view, String url, Bitmap favicon) {<br>         //设定加载开始的操作<br>      }<br>  });</p><p>常见方法3：onPageFinished()</p><p>作用：在页面加载结束时调用。我们可以关闭loading 条，切换程序动作。<br>    webView.setWebViewClient(new WebViewClient(){<br>      @Override<br>      public void onPageFinished(WebView view, String url) {<br>         //设定加载结束的操作<br>      }<br>  });</p><p>常见方法4：onLoadResource()</p><p>作用：在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。<br>    webView.setWebViewClient(new WebViewClient(){<br>      @Override<br>      public boolean onLoadResource(WebView view, String url) {<br>         //设定加载资源的操作<br>      }<br>  });</p><p>常见方法5：onReceivedError（）</p><p>作用：加载页面的服务器出现错误时（如404）调用。<br>App里面使用webview控件的时候遇到了诸如404这类的错误的时候，若也显示浏览器里面的那种错误提示页面就显得很丑陋了，那么这个时候我们的app就需要加载一个本地的错误提示页面，即webview如何加载一个本地的页面<br>//步骤1：写一个html文件（error_handle.html），用于出错时展示给用户看的提示页面<br>//步骤2：将该html文件放置到代码根目录的assets文件夹下</p><p>//步骤3：复写WebViewClient的onRecievedError方法<br>//该方法传回了错误码，根据错误类型可以进行不同的错误分类处理<br>    webView.setWebViewClient(new WebViewClient(){<br>      @Override<br>      public void onReceivedError(WebView view, int errorCode, String description, String failingUrl){<br>switch(errorCode)<br>                {<br>                case HttpStatus.SC_NOT_FOUND:<br>                    view.loadUrl(“file:///android_assets/error_handle.html”);<br>                    break;<br>                }<br>            }<br>        });</p><p>常见方法6：onReceivedSslError()</p><p>作用：处理https请求<br>webView默认是不处理https请求的，页面显示空白，需要进行如下设置：<br>webView.setWebViewClient(new WebViewClient() {<br>        @Override<br>        public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {<br>            handler.proceed();    //表示等待证书响应<br>        // handler.cancel();      //表示挂起连接，为默认方式<br>        // handler.handleMessage(null);    //可做其他处理<br>        }<br>    });    </p><p>1.4 WebChromeClient类</p><p>作用：辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。<br>常见使用：<br>常见方法1： onProgressChanged（）</p><p>作用：获得网页的加载进度并显示<br>webview.setWebChromeClient(new WebChromeClient(){</p><pre><code>  @Override  public void onProgressChanged(WebView view, int newProgress) {      if (newProgress &lt; 100) {          String progress = newProgress + &quot;%&quot;;          progress.setText(progress);        } else {    }});</code></pre><p>常见方法2： onReceivedTitle（）</p><p>作用：获取Web页中的标题<br>每个网页的页面都有一个标题，比如www.baidu.com这个页面的标题即“百度一下，你就知道”，那么如何知道当前webview正在加载的页面的title并进行设置呢？<br>webview.setWebChromeClient(new WebChromeClient(){</p><pre><code>@Overridepublic void onReceivedTitle(WebView view, String title) {   titleview.setText(title)；}注意事项：如何避免WebView内存泄露？不在xml中定义 Webview ，而是在需要的时候在Activity中创建，并且Context使用 getApplicationgContext()LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);    mWebView = new WebView(getApplicationContext());    mWebView.setLayoutParams(params);    mLayout.addView(mWebView);在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空。@Overrideprotected void onDestroy() {    if (mWebView != null) {        mWebView.loadDataWithBaseURL(null, &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);        mWebView.clearHistory();        ((ViewGroup) mWebView.getParent()).removeView(mWebView);        mWebView.destroy();        mWebView = null;    }    super.onDestroy();}</code></pre>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rxjava 操作符简略</title>
      <link href="/2017/12/12/rxjava%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%AE%80%E7%95%A5/"/>
      <content type="html"><![CDATA[<p>rxjava </p><p>变换字符：Map()/FlatMap/ConcatMap()/Buffer()/delay()/do()/onErrorReturn()/onErrorResumeNext()/onExceptionResumeNext()/retry()/retryUntil()/retryWhen()/repeat()/repeatWhen()/<br>1.Map 作用：对被观察者发送的每1个事件都通过 指定的函数 处理，从而变换成另外一种事件 场景：数据类型转换<br>2.FlatMap 作用：将被观察者发送的事件进行拆分&amp;单独转换，在合并成一个新的事件序列，最后进行发送。 场景：无序的将被观察者发送的整个事件序列进行变换<br>3.ConcatMap 作用：类似FlatMap() 操作符  与FlatMap（）的 区别在于：拆分 &amp; 重新合并生成的事件序列 的顺序 = 被观察者旧序列生产的顺序 场景：有序的将被观察者发送的整个事件序列进行变换<br>4.Buffer 作用：定期从 被观察者（Obervable）需要发送的事件中 获取一定数量的事件 &amp; 放到缓存区中，最终发送 场景：缓存被观察者发送的事件<br>5.delay 作用：使得被观察者延迟一段时间再发送事件 [observable]</p><p>1.在事件的生命周期中操作<br>6.do 作用：在某个事件的生命周期中调用<br>0601：doOnEach/onNext/onError/onCompleted 当observable每次发送一次数据事件就会调用<br>0602：doOnNext/doAftetNext  执行Next事件前调用/执行Next事件后调用<br>0603：doError()/doOnCompleted()/doOnTerminate()/doFianlly() 发送错误事件时/正常发送事件完毕后/无论正常发送或异常终止/最后执行<br>0604：doOnSubscribe()/doOnUnsubscribe() 观察者订阅时调用/观察者取消订阅时调用</p><p>2.错误处理 场景：发送事件过程中，遇到错误时的处理机制<br>1.onErrorResumeNext（）拦截的错误 = Throwable；若需拦截Exception请用onExceptionResumeNext（）<br>2.若onErrorResumeNext（）拦截的错误 = Exception，则会将错误传递给观察者的onError方法</p><p>7.onErrorReturn 作用：遇到错误时，发送1个特殊事件&amp;正常终止<br>8.onErrorResumeNext 作用：遇到错误时，发送1个新的Observable<br>9.onExceptionResumeNext  作用：遇到错误时，发送1个新的Observable<br>10.retry 作用：重试，即当出现错误时，让被观察者（Observable）重新发射数据<br>11.retryUntil 作用： 出现错误后，判断是否需要重新发送数据<br>1101.若需要重新发送 &amp; 持续遇到错误，则持续重试<br>1102.作用类似于retry（Predicate predicate）<br>12.retryWhen 作用：遇到错误时，将发生的错误传递给一个新的被观察者（Observable），并决定是否需要重新订阅原始被观察者（Observable）&amp; 发送事件<br>13.repeat 作用：无条件地、重复发送 被观察者事件<br>14.repeatWhen 作用：有条件地、重复发送 被观察者事件</p><p>合并操/组合操作符<br>1.组合多个被观察者  顺序：concat concatArray 时间：merge mergeArray 错误处理：concatDelayError mergeDelayError<br>2.合并多个事件      数量：zip 时间：combineLatest combineLatestDelayError  合并成1个事件发送 reduce collect<br>3.发送事件前追加发送事件  startWith startWithArray<br>4.统计发送事件数量        count </p><p>1.concat 作用：组合多个被观察者一起发送数据，合并后 按发送顺序串行执行  二者区别：组合被观察者的数量，即concat（）组合被观察者数量≤4个，而concatArray（）则可＞4个<br>2.merge  作用：组合多个被观察者一起发送数据，合并后 按时间线并行执行  区别上述concat（）操作符：同样是组合多个被观察者一起发送数据，但concat（）操作符合并后是按发送顺序串行执行<br>3.concatDelayError 如果事件出现异常 决定是否继续发送<br>4.zip 作用：合并 多个被观察者（Observable）发送的事件，生成一个新的事件序列（即组合过后的事件序列），并最终发送  场景：当需要展示的信息需要从多个地方获取(即信息 = 信息1 + 信息2 )&amp;统一结合后再展示 如合并网络请求的发送&amp;统一显示结果<br>5.combineLatest  作用：当两个Observables中的任何一个发送了数据后，将先发送了数据的Observables 的最新（最后）一个数据 与 另外一个Observable发送的每个数据结合，最终基于该函数的结果发送数据<br>6.reduce  作用：把被观察者需要发送的事件聚合成1个事件 &amp; 发送 聚合的逻辑根据需求撰写，但本质都是前2个数据聚合，然后与后1个数据继续进行聚合，依次类推<br>7.collect 作用：将被观察者Observable发送的数据事件收集到一个数据结构里<br>8.startWith / startWithArray  作用：在一个被观察者发送事件前，追加发送一些数据 / 一个新的被观察者<br>9.conunt 作用：统计被观察者发送事件的数量</p>]]></content>
      
      <categories>
          
          <category> rxjava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> rxjava </tag>
            
            <tag> rxandroid </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue 目录解析</title>
      <link href="/2017/11/08/vue%20%E7%9B%AE%E5%BD%95%E8%A7%A3%E6%9E%90/"/>
      <content type="html"><![CDATA[<h1 id="vue-目录解析"><a href="#vue-目录解析" class="headerlink" title="vue 目录解析"></a>vue 目录解析</h1><p>├── build/                      # webpack config files / webpack 配置文件<br>│   └── …<br>├── config/<br>│   ├── index.js                # main project config / 项目主要配置<br>│   └── …<br>├── src/                        # 主要的项目开发文件都在这个目录下：<br>│   ├── main.js                 # app entry file / 应用入口文件<br>│   ├── App.vue                 # main app component / App 父组件<br>│   ├── components/             # ui components / 可复用的 ui 组件<br>│   │   └── …<br>│   ├── assets/                 # module assets (processed by webpack) / 模块资源（经过 webpack 处理，如文件合并，图片压缩等）<br>│   │   └── …<br>│   ├── page/                   ## 以页面为单位的 .vue 文件<br>│   │   ├── index.vue           ## 一级 router-view，顶部导航栏和左侧侧边导航栏<br>│   │   ├── 404.vue             ## 404 页面<br>│   │   ├── menu1/              ## 二级 router-view，导航切换后的页面内容<br>│   │   │   └── …<br>│   │   └── menu2/              ## 按照菜单项创建文件夹对文件进行组织管理<br>│   │       └── …<br>│   └── router/<br>│       └── index.js            # 路由配置文件<br>├── static/                     # pure static assets (directly copied) / 纯静态资源（直接拷贝使用，不经过 webpack 处理）<br>├── .babelrc                    # babel config<br>├── .eslintrc.js                # eslint config<br>├── .editorconfig               # editor config<br>├── index.html                  # index.html template<br>├── package.json                # build scripts and dependencies<br>└── …</p><p>关闭Eslint：<br>build/webpack.base.conf.js<br>module: {<br>    rules: [<br>      // {<br>      //   test: /.(js|vue)$/,<br>      //   loader: ‘eslint-loader’,<br>      //   enforce: “pre”,<br>      //   include: [resolve(‘src’), resolve(‘test’)],<br>      //   options: {<br>      //     formatter: require(‘eslint-friendly-formatter’)<br>      //   }<br>      // },<br>      {<br>        test: /.vue$/,<br>        loader: ‘vue-loader’,<br>        options: vueLoaderConfig<br>      },<br>      …<br>    ]<br>  },</p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android SO文件的兼容和适配</title>
      <link href="/2017/11/08/android%20os%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%BC%E5%AE%B9%E5%92%8C%E9%80%82%E9%85%8D/"/>
      <content type="html"><![CDATA[<h1 id="Android-SO文件的兼容和适配"><a href="#Android-SO文件的兼容和适配" class="headerlink" title="Android SO文件的兼容和适配"></a>Android SO文件的兼容和适配</h1><p>开发Android应用时，有时候Java层的编码不能满足实现需求，就需要到C/C++实现后生成SO文件，再用System.loadLibrary()加载进行调用，这里成为JNI层的实现。常见的场景如：加解密算法，音视频编解码等。在生成SO文件时，需要考虑适配市面上不同手机CPU架构，而生成支持不同平台的SO文件进行兼容。目前Android共支持七种不同类型的CPU架构，分别是：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)。如果你要完美兼容所有类型的手机，理论上是要在的libs目录下放置各个架构平台的SO文件。<br><img src="https://diycode.b0.upaiyun.com/photo/2017/e4bd7d20f209338dad541a8062e06518.png" alt="此处输入图片的描述"></p><p>  这样一来，虽然可以兼容所有机型，但你的项目体积也会变得非常庞大。是否一定需要带入这么多SO文件去兼容呢？答案是否定的。<br>  <a id="more"></a><br>  <strong>SO（CPU）的兼容</strong><br>  对于CPU来说，不同的架构并不意味着一定互不兼容，根据目前Android共支持七种不同类型的CPU架构，其兼容特点可总结如下：</p><p>armeabi设备只兼容armeabi；<br>armeabi-v7a设备兼容armeabi-v7a、armeabi；<br>arm64-v8a设备兼容arm64-v8a、armeabi-v7a、armeabi；<br>X86设备兼容X86、armeabi；<br>X86_64设备兼容X86_64、X86、armeabi；<br>mips64设备兼容mips64、mips；<br>mips只兼容mips；<br>根据以上的兼容总结，我们还可以得到一些规律：</p><p>armeabi的SO文件基本上可以说是万金油，它能运行在除了mips和mips64的设备上，但在非armeabi设备上运行性能还是有所损耗；<br>64位的CPU架构总能向下兼容其对应的32位指令集，如：x86_64兼容X86，arm64-v8a兼容armeabi-v7a，mips64兼容mips；<br>关于SO的兼容规律就介绍到此，下面谈谈适配工作。</p><p><strong>SO的适配</strong><br>从目前移动端CPU市场的份额数据看，ARM架构几乎垄断，所以，除非你的用户很特殊，否则几乎可以不考虑单独编译带入X86、X86_64、mips、mips64架构SO文件。除去这四个架构之后，还要带入armeabi、armeabi-v7a、arm64-v8a这三个不同类型，这对于一个拥有大量SO文件的应用来说，安装包的体积将会增大不少。</p><p>针对以上情况，我们可以应用的设备分布和市场情况再进行取舍斟酌，如果你的应用仍有不少armeabi类型的设备，可以考虑只保留armeabi目录下的SO文件（万金油特性）。但是，尽管armeabi可以兼容多种平台，仍有些运算在armeabi-v7a、arm64-v8a去使用armeabi的SO文件时，性能会非常差强人意，所以还是应该用其对应平台架构的SO文件进行运算。注意，这里并不是要带多一整套SO文件到不同的目录下，而是将性能差异比较明显的某个armeabi-v7a、arm64-v8a平台下的SO文件放到armeabi目录，然后通过代码判断设备的CPU类型，再加载其对应架构的SO文件，很多大厂的应用便是这么做的。如微信的lib下虽然只有armeabi一个目录，但目录内的文件仍放着v5、v7a架构的SO文件，用于处理兼容带来的某些性能运算问题。<br><img src="https://diycode.b0.upaiyun.com/photo/2017/47ea43173eda402b66d1d03e7fc8351f.png" alt="此处输入图片的描述"></p><p>就目前市场份额而言，绝大部分的设备都已经是armeabi-v7a、arm64-v8a，你也可以考虑只保留armeabi-v7a架构的SO文件，这样能获得更好的性能效果。</p><p>总结</p><p>以上便是关于SO文件兼容适配的一点总结梳理，如有错误，欢迎指出。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac android studio 几个文件夹夹路径</title>
      <link href="/2017/11/08/mac%20android%20studio%20%E5%87%A0%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E8%B7%AF%E5%BE%84/"/>
      <content type="html"><![CDATA[<h1 id="vue-目录解析"><a href="#vue-目录解析" class="headerlink" title="vue 目录解析"></a>vue 目录解析</h1><p>在mac资源目录下保存的的目录地址</p><p>gradle 关系文件</p><p>~/.gradle</p><p>Android 模拟器(AVDs) and *.keystore 文件</p><p>~/.android</p><p>Android SDK 工具</p><p>~/Library/Android*</p><p>完全移除android studio终端中执行下列命令</p><p>rm -Rf /Applications/Android\ Studio.app<br>rm -Rf ~/Library/Preferences/AndroidStudio<em><br>rm -Rf ~/Library/Preferences/com.google.android.studio.plist<br>rm -Rf ~/Library/Application\ Support/AndroidStudio</em><br>rm -Rf ~/Library/Logs/AndroidStudio<em><br>rm -Rf ~/Library/Caches/AndroidStudio</em></p>]]></content>
      
      <categories>
          
          <category> android studio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java List 删除数据问题</title>
      <link href="/2017/11/05/java%20List%20%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> void test() &#123;</span><br><span class="line">    List&lt;String&gt; list = </span><br><span class="line">    new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);</span><br><span class="line">    );</span><br><span class="line">    //第一种方式</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        if (str.contains(&quot;b&quot; )) &#123;</span><br><span class="line">            list.remove(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种方式</span><br><span class="line">    int size = list.size();</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        String str = list.get(i);</span><br><span class="line">        if (str.contains(&quot;b&quot; )) &#123;</span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //第三种方式</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        String str = list.get(i);</span><br><span class="line">        if (str.contains(&quot;b&quot; )) &#123;</span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //第四种方式</span><br><span class="line">    for (Iterator&lt;String&gt; ite = list.iterator(); ite.hasNext(); ) &#123;</span><br><span class="line">        String str = ite.next();</span><br><span class="line">        if (str.contains(&quot;b&quot; )) &#123;</span><br><span class="line">            ite.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第五种方式</span><br><span class="line">    for (Iterator&lt;String&gt; ite = list.iterator(); ite.hasNext(); ) &#123;</span><br><span class="line">        String str = ite.next();</span><br><span class="line">        if (str.contains(&quot;b&quot; )) &#123;</span><br><span class="line">            list.remove(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式一：报错java.util.ConcurrentModificationException<br>方式二：报错：下标越界 java.lang.IndexOutOfBoundsException<br>    list大小会发生变化，索引也会变化。导致你在遍历的时候漏掉某些元素，当删除第1个元素后，继续根据索引访问第2个元素时，因为删除的关系后面的元素都会往前移动一位，所以实际访问的是第3个元素，因此，这种方式可以用在删除特定的一个元素时使用，但不适合循环删除多个元素时使用。<br>方式三：正常删除，不推荐，每次循环都需要计算list的大小，效率低。<br>方式四：正常删除，推荐使用<br>方式五：报错：java.util.ConcurrentModificationException</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Fragment库区别</title>
      <link href="/2017/09/22/Fragment%E5%BA%93%E5%8C%BA%E5%88%AB/"/>
      <content type="html"><![CDATA[<p>在做项目时，同事把基础fragment类中的Android.support.v4.app.Fragment改成了android.app.Fragment，导致了一些问题，今天特别来标注一下：</p><p>强烈推荐使用android.support.v4.app.Fragment，不过依然要了解为什么？？</p><p>1.最低支持版本不同</p><p>android.app.Fragment 兼容的最低版本是android:minSdkVersion=”11” 即3.0版</p><p>android.support.v4.app.Fragment 兼容的最低版本是android:minSdkVersion=”4” 即1.6版</p><p>2.需要导jar包</p><p>fragment android.support.v4.app.Fragment 需要引入包android-support-v4.jar</p><p>3.获取manager的方法不同</p><p>android.app.Fragment使用getFragmentManager()</p><p>android.support.v4.app.Fragment使用getSupportFragmentManager()</p><p>注意:</p><p>android.support.v4.app.Fragment不能使用<fragment>标签</fragment></p><p>而且想用fragment+viewpager只能使用android.support.v4.app.Fragment，因为FragmentPagerAdapter就是android.support.v4.app.Fragment才有。</p><p>切记！！ android.support.v4.app.Fragment与android.app.Fragment不要混用。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>androidHttps搭建与服务器Tomcat9.0配置</title>
      <link href="/2017/06/08/androidHttps%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8Tomcat9-0%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<p><a href="http://www.jianshu.com/p/64172ccfb73b" target="_blank" rel="noopener">http://www.jianshu.com/p/64172ccfb73b</a><br><a href="http://www.cnblogs.com/LoganChen/p/6369774.html" target="_blank" rel="noopener">http://www.cnblogs.com/LoganChen/p/6369774.html</a></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>androidStudio编译与运行常见问题</title>
      <link href="/2017/03/30/androidStudio%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<p>最近开发公司一个项目，环信客服SDK的demo接入。android5.0的手机大部分可以正确使用，<br>其他之下的手机会报java.lang.VerifyError.。之前以为环信客服SDK的兼容问题，后来把融云屏蔽掉，<br>后面又接连报错，才意思到是我项目出问题，百度了一些资料，才发现java.lang.VerifyError有几种情况会报错;<br>google的官方说法是：java.lang.VerifyError是adt与jdk的不同版本的不同，进入架包之类的会报错各种不同的错误，是无法机器无法解决的。<br><a id="more"></a><br>解决方法一<br><img src="http://wx1.sinaimg.cn/mw690/005zrb37gy1fe4ts34rolj30fy08v0ta.jpg" alt="此处输入图片的描述"></p><p>但是，不要忘记，这只是让你app的编辑文件分成2分，你软件运行有可能只运行第一个软件，它是默认运行的，有可能会报VerifyError。<br>Apk在运行的时候，有一个dexpathlist，而Multidex的源码中，会根据你的系统版本号对dexpathlist做修改，将所有的dex都添加到dexpathlist中.<br>接下来集成有两个步骤:<br>一. 从sdk\extras\android\support\multidex\library\libs 目录将android-support-multidex.jar导入工程中<br>二. 如果你的工程中已经含有Application类,那么让它继承android.support.multidex.MultiDexApplication类,<br>     如果你的Application已经继承了其他类并且不想做改动，那么还有另外一种使用方式,覆写attachBaseContext()方法:</p><p><img src="http://wx4.sinaimg.cn/mw690/005zrb37gy1fe4ttmdlavj30jq06iwen.jpg" alt="此处输入图片的描述">     </p><p>网上的一些解释是：app项目过大，必须分成2个Dex文件，Android studio才会运行正常。</p><p>这样才能让你的两个dex文件合并在一起，不会报异常了。<br>解决方法二:<br>我只说使用android studio的情况，有可能是你的升级android studio2.0出现的问题 Android Studio 2.0带来了很多新功能和优化，其中最让我兴奋的是Instant Run和Gradle编译速度的提升，虽然预览版bug多，但是程序员怕这个？<br>网上处理的方法是：解决方法就是把Gradle版本改回去，改成1.5版本比较稳定，不会出现问题<br>解决方法三:<br>最后一种是，我也没有碰见过，但是我看着比较靠谱，所有写下来，哈哈  我的记性比较差，请原谅我这个智障哦/(ㄒoㄒ)/~~。<br>你的LibRARY架包包含的.class源文件与你自己module内的一个架包一个源文件.class文件冲突，所有你可以通过ctrl+N,可以在android studio中遍历你的.class源文件，删除其中一个，运行是ok的。</p><p>由于是第一次写，有点没头没脑，只要是想给那些遇见跟我一样问题的人  一些解决方案 O(∩_∩)O哈哈~，不过这个问题我难了一个月，头疼死了。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>反编译操作</title>
      <link href="/2017/03/05/%E5%8F%8D%E7%BC%96%E8%AF%91%E6%93%8D%E4%BD%9C/"/>
      <content type="html"><![CDATA[<p>使用apktool进行反编译获取XML资源文件 </p><p>apktool d -f c:\test.apk -o c:\test 其中，c:\test.apk表示要反编译的apk；c:\test表示反编译后需要保存的文件名字</p><p>apktool d -f  c:\test2.apk -o c:\test2</p><p>使用dex2jar-0.0.9.15 进行反编译获取源代码。</p><p>dex2jar.bar classes.dex</p><p>rxjava2 操作符号大全<br><a href="https://blog.csdn.net/philos3/article/details/78314865" target="_blank" rel="noopener">https://blog.csdn.net/philos3/article/details/78314865</a><br>RxJava2.0 操作符<br><a href="https://www.jianshu.com/p/60ceafe8f8d0" target="_blank" rel="noopener">https://www.jianshu.com/p/60ceafe8f8d0</a><br>线程锁<br><a href="https://www.cnblogs.com/qjjazry/p/6581568.html" target="_blank" rel="noopener">https://www.cnblogs.com/qjjazry/p/6581568.html</a></p><p>dagger.android使用<br><a href="https://www.jianshu.com/p/6d3b1805f5e5" target="_blank" rel="noopener">https://www.jianshu.com/p/6d3b1805f5e5</a><br><a href="https://blog.csdn.net/qq_17766199/article/details/73030696" target="_blank" rel="noopener">https://blog.csdn.net/qq_17766199/article/details/73030696</a><br><a href="https://blog.csdn.net/soslinken/article/details/70231089" target="_blank" rel="noopener">https://blog.csdn.net/soslinken/article/details/70231089</a><br><a href="https://blog.csdn.net/u010961631/article/details/72626134" target="_blank" rel="noopener">https://blog.csdn.net/u010961631/article/details/72626134</a></p><p><a href="https://www.colabug.com/2662538.html" target="_blank" rel="noopener">https://www.colabug.com/2662538.html</a><br><a href="http://www.xitongzhijia.net/xtjc/20170310/93698.html" target="_blank" rel="noopener">http://www.xitongzhijia.net/xtjc/20170310/93698.html</a></p><p>ndk问题<br><a href="https://blog.csdn.net/qq_34476727/article/details/74910379" target="_blank" rel="noopener">https://blog.csdn.net/qq_34476727/article/details/74910379</a></p>]]></content>
      
      <categories>
          
          <category> apk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android6.0运行时权限列表</title>
      <link href="/2017/02/15/android6-0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8/"/>
      <content type="html"><![CDATA[<p>新的权限机制更好的保护了用户的隐私，Google将权限分为两类，一类是Normal Permissions，这类权限一般不涉及用户隐私，是不需要用户进行授权的，比如手机震动、访问网络等；另一类是Dangerous Permission，一般是涉及到用户隐私的，需要用户进行授权，比如读取sdcard、访问通讯录等。<br><a id="more"></a><br>1.Normal Permissions如下</p><p>ACCESS_LOCATION_EXTRA_COMMANDS<br>ACCESS_NETWORK_STATE<br>ACCESS_NOTIFICATION_POLICY<br>ACCESS_WIFI_STATE<br>BLUETOOTH<br>BLUETOOTH_ADMIN<br>BROADCAST_STICKY<br>CHANGE_NETWORK_STATE<br>CHANGE_WIFI_MULTICAST_STATE<br>CHANGE_WIFI_STATE<br>DISABLE_KEYGUARD<br>EXPAND_STATUS_BAR<br>GET_PACKAGE_SIZE<br>INSTALL_SHORTCUT<br>INTERNET<br>KILL_BACKGROUND_PROCESSES<br>MODIFY_AUDIO_SETTINGS<br>NFC<br>READ_SYNC_SETTINGS<br>READ_SYNC_STATS<br>RECEIVE_BOOT_COMPLETED<br>REORDER_TASKS<br>REQUEST_INSTALL_PACKAGES<br>SET_ALARM<br>SET_TIME_ZONE<br>SET_WALLPAPER<br>SET_WALLPAPER_HINTS<br>TRANSMIT_IR<br>UNINSTALL_SHORTCUT<br>USE_FINGERPRINT<br>VIBRATE<br>WAKE_LOCK<br>WRITE_SYNC_SETTINGS</p><p>2.Dangerous Permissions:</p><p>group:android.permission-group.CONTACTS<br>　permission:android.permission.WRITE_CONTACTS<br>　permission:android.permission.GET_ACCOUNTS<br>　permission:android.permission.READ_CONTACTS</p><p>group:android.permission-group.PHONE<br>　permission:android.permission.READ_CALL_LOG<br>　permission:android.permission.READ_PHONE_STATE<br>　permission:android.permission.CALL_PHONE<br>　permission:android.permission.WRITE_CALL_LOG<br>　permission:android.permission.USE_SIP<br>　permission:android.permission.PROCESS_OUTGOING_CALLS<br>　permission:com.android.voicemail.permission.ADD_VOICEMAIL</p><p>group:android.permission-group.CALENDAR<br>　permission:android.permission.READ_CALENDAR<br>　permission:android.permission.WRITE_CALENDAR</p><p>group:android.permission-group.CAMERA<br>　permission:android.permission.CAMERA</p><p>group:android.permission-group.SENSORS<br>　permission:android.permission.BODY_SENSORS</p><p>group:android.permission-group.LOCATION<br>　permission:android.permission.ACCESS_FINE_LOCATION<br>　permission:android.permission.ACCESS_COARSE_LOCATION</p><p>group:android.permission-group.STORAGE<br>　permission:android.permission.READ_EXTERNAL_STORAGE<br>　permission:android.permission.WRITE_EXTERNAL_STORAGE</p><p>group:android.permission-group.MICROPHONE<br>　permission:android.permission.RECORD_AUDIO</p><p>group:android.permission-group.SMS<br>　permission:android.permission.READ_SMS<br>　permission:android.permission.RECEIVE_WAP_PUSH<br>　permission:android.permission.RECEIVE_MMS<br>　permission:android.permission.RECEIVE_SMS<br>　permission:android.permission.SEND_SMS<br>　permission:android.permission.READ_CELL_BROADCASTS</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android快捷键</title>
      <link href="/2017/01/12/android%20%E5%BF%AB%E6%8D%B7%E9%94%AE%20/"/>
      <content type="html"><![CDATA[<p>Ctrl<br>Ctrl + F 在当前文件进行文本查找（必备）</p><p>Ctrl + R 在当前文件进行文本替换（必备）</p><p>Ctrl + Z 撤销（必备） Ctrl + Shift + Z ：还原修改</p><p>Ctrl + Y 删除光标所在行或删除选中的行（必备）</p><p>Ctrl + X 剪切光标所在行或剪切选择内容</p><a id="more"></a> <p>Ctrl + C 复制光标所在行或复制选择内容</p><p>Ctrl + D 复制光标所在行或复制选择内容，并把复制内容插入光标位置下面（必备）</p><p>Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围（必备）</p><p>Ctrl + E 显示最近打开的文件记录列表</p><p>Ctrl + N 根据输入的类名查找类文件</p><p>Ctrl + G 在当前文件跳转到指定行处</p><p>Ctrl + J 插入自定义动态代码模板</p><p>Ctrl + P 方法参数提示显示</p><p>Ctrl + Q 光标所在的变量/ 类名/ 方法名等上面（也可以在提示补充的时候按），显示文档内容</p><p>Ctrl + U 前往当前光标所在的方法的父类的方法/ 接口定义</p><p>Ctrl + B 进入光标所在的方法/变量的接口或是定义出，等效于Ctrl + 左键单击</p><p>Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用</p><p>Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用</p><p>Ctrl + H 显示当前类的层次结构</p><p>Ctrl + O 选择可重写的方法</p><p>Ctrl + I 选择可继承的方法</p><p>Ctrl + + 展开代码</p><p>Ctrl + - 折叠代码</p><p>Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号（必备）</p><p>Ctrl + [ 移动光标到当前所在代码的花括号开始位置</p><p>Ctrl + ] 移动光标到当前所在代码的花括号结束位置</p><p>Ctrl + F1 在光标所在的错误代码出显示错误信息</p><p>Ctrl + F3 | F3 调转到所选中的词的下一个引用位置</p><p>Shift + F3 调转到所选中的词的上一个引用位置</p><p>Ctrl + F4 关闭当前编辑文件</p><p>Ctrl + F8 在Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</p><p>Ctrl + F9 执行Make Project 操作</p><p>Ctrl + F11 选中文件/ 文件夹，使用助记符设定/ 取消书签</p><p>Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</p><p>Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</p><p>Ctrl + Enter 智能分隔行</p><p>Ctrl + End 跳到文件尾</p><p>Ctrl + Home 跳到文件头</p><p>Ctrl + Space 基础代码补全，默认在Windows 系统上被输入法占用，需要进行修改，建议修改为Ctrl + 逗号（必备）</p><p>Ctrl + Delete 删除光标后面的单词或是中文句</p><p>Ctrl + BackSpace 删除光标前面的单词或是中文句</p><p>Ctrl + 1,2,3…9 定位到对应数值的书签位置(可作为备用键)</p><p>Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径</p><p>Ctrl + 光标定位 按Ctrl 不要松开，会显示光标所在的类信息摘要</p><p>Ctrl + 左方向键 光标跳转到当前单词/ 中文句的左侧开头位置</p><p>Ctrl + 右方向键 光标跳转到当前单词/ 中文句的右侧开头位置</p><p>Ctrl + 前方向键 等效于鼠标滚轮向前效果</p><p>Ctrl + 后方向键 等效于鼠标滚轮向后效果</p><p>Alt</p><p>Alt + ` 显示版本控制常用操作菜单弹出层</p><p>Alt + Q 弹出一个提示，显示当前类的声明/ 上下文信息</p><p>Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</p><p>Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层</p><p>Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示</p><p>Alt + F7 查找光标所在的方法/ 变量/ 类被调用的地方</p><p>Alt + F8 在Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</p><p>Alt + Home 定位/ 显示到当前文件的Navigation Bar</p><p>Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同（必备）</p><p>Alt + Insert 代码自动生成，如生成对象的set / get 方法，构造函数，toString() 等</p><p>Alt + 左方向键 按左方向切换当前已打开的文件视图</p><p>Alt + 右方向键 按右方向切换当前已打开的文件视图</p><p>Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置</p><p>Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置</p><p>Alt + 1,2,3…9 显示对应数值的选项卡，其中1 是Project 用得最多（除了1和5以为，其他可以当备用键）</p><p>Shift</p><p>Shift + F1 如果有外部文档可以连接外部文档</p><p>Shift + F2 跳转到上一个高亮错误或警告位置</p><p>Shift + F3 在查找模式下，查找匹配上一个</p><p>Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留</p><p>Shift + F6 对文件/ 文件夹重命名</p><p>Shift + F7 在Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</p><p>Shift + F8 在Debug 模式下，跳出，表现出来的效果跟F9 一样</p><p>Shift + F9 等效于点击工具栏的Debug 按钮</p><p>Shift + F10 等效于点击工具栏的Run 按钮</p><p>Shift + F11 弹出书签显示层</p><p>Shift + Tab 取消缩进</p><p>Shift + ESC 隐藏当前或最后一个激活的工具窗口</p><p>Shift + End 选中光标到当前行尾位置</p><p>Shift + Home 选中光标到当前行头位置</p><p>Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置</p><p>Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件</p><p>Shift + 滚轮前后滚动当前文件的横向滚动轴滚动</p><p>Ctrl + Alt</p><p>Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用（必备）</p><p>Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用（必备）</p><p>Ctrl + Alt + I 光标所在行或选中部分进行自动代码缩进，有点类似格式化</p><p>Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层</p><p>Ctrl + Alt + J 弹出模板选择窗口，讲选定的代码加入动态模板中</p><p>Ctrl + Alt + H 调用层次</p><p>Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</p><p>Ctrl + Alt + V 快速引进变量</p><p>Ctrl + Alt + Y 同步、刷新</p><p>Ctrl + Alt + S 打开IntelliJ IDEA 系统设置</p><p>Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</p><p>Ctrl + Alt + F11 切换全屏模式</p><p>Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行</p><p>Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层</p><p>Ctrl + Alt + Space 类名自动完成</p><p>Ctrl + Alt + 左方向键退回到上一个操作的地方（必备）</p><p>Ctrl + Alt + 右方向键前进到上一个操作的地方（必备）</p><p>Ctrl + Alt + 前方向键在查找模式下，跳到上个查找的文件</p><p>Ctrl + Alt + 后方向键在查找模式下，跳到下个查找的文件</p><p>Ctrl + Shift</p><p>快捷键介绍</p><p>Ctrl + Shift + F根据输入内容查找整个项目或指定目录内文件（必备）</p><p>Ctrl + Shift + R根据输入内容替换对应内容，范围为整个项目或指定目录内文件（必备）</p><p>Ctrl + Shift + J自动将下一行合并到当前行末尾（必备）</p><p>Ctrl + Shift + Z取消撤销（必备）</p><p>Ctrl + Shift + W递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围（必备）</p><p>Ctrl + Shift + N通过文件名定位/ 打开文件/ 目录，打开目录需要在输入的内容后面多加一个正斜杠（必备）</p><p>Ctrl + Shift + U对选中的代码进行大/ 小写轮流转换（必备）</p><p>Ctrl + Shift + T对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</p><p>Ctrl + Shift + C复制当前文件磁盘路径到剪贴板</p><p>Ctrl + Shift + V弹出缓存的最近拷贝的内容管理器弹出层</p><p>Ctrl + Shift + E显示最近修改的文件列表的弹出层</p><p>Ctrl + Shift + H显示方法层次结构</p><p>Ctrl + Shift + B跳转到类型声明处</p><p>Ctrl + Shift + I快速查看光标所在的方法或类的定义</p><p>Ctrl + Shift + A查找动作/ 设置</p><p>Ctrl + Shift + /代码块注释（必备）</p><p>Ctrl + Shift + [选中从光标所在位置到它的顶部中括号位置</p><p>Ctrl + Shift + ]选中从光标所在位置到它的底部中括号位置</p><p>Ctrl + Shift + +展开所有代码</p><p>Ctrl + Shift + -折叠所有代码</p><p>Ctrl + Shift + F7高亮显示所有该选中文本，按Esc高亮消失</p><p>Ctrl + Shift + F8在Debug 模式下，指定断点进入条件</p><p>Ctrl + Shift + F9编译选中的文件/ 包/ Module</p><p>Ctrl + Shift + F12编辑器最大化</p><p>Ctrl + Shift + Space智能代码提示</p><p>Ctrl + Shift + Enter自动结束代码，行末自动添加分号（必备）</p><p>Ctrl + Shift + Backspace退回到上次修改的地方</p><p>Ctrl + Shift + 1,2,3…9快速添加指定数值的书签(可以充当快捷键)</p><p>Ctrl + Shift + 左方向键在代码文件上，光标跳转到当前单词/ 中文句的左侧开头位置，同时选中该单词/ 中文句</p><p>Ctrl + Shift + 右方向键在代码文件上，光标跳转到当前单词/ 中文句的右侧开头位置，同时选中该单词/ 中文句</p><p>Ctrl + Shift + 左方向键在光标焦点是在工具选项卡上，缩小选项卡区域</p><p>Ctrl + Shift + 右方向键在光标焦点是在工具选项卡上，扩大选项卡区域</p><p>Ctrl + Shift + 前方向键光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</p><p>Ctrl + Shift + 后方向键光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</p><p>Alt + Shift</p><p>快捷键介绍</p><p>Alt + Shift + N选择/ 添加task</p><p>Alt + Shift + F显示添加到收藏夹弹出层</p><p>Alt + Shift + C查看最近操作项目的变化情况列表</p><p>Alt + Shift + F添加到收藏夹</p><p>Alt + Shift + I查看项目当前文件</p><p>Alt + Shift + F7在Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</p><p>Alt + Shift + F9弹出Debug 的可选择菜单</p><p>Alt + Shift + F10弹出Run 的可选择菜单</p><p>Alt + Shift + 左键双击选择被双击的单词/ 中文句，按住不放，可以同时选择其他单词/ 中文句</p><p>Alt + Shift + 前方向键移动光标所在行向上移动</p><p>Alt + Shift + 后方向键移动光标所在行向下移动</p><p>Ctrl + Shift + Alt</p><p>快捷键介绍</p><p>Ctrl + Shift + Alt + V无格式黏贴</p><p>Ctrl + Shift + Alt + N前往指定的变量/ 方法</p><p>Ctrl + Shift + Alt + S打开当前项目设置</p><p>Ctrl + Shift + Alt + C复制参考信息</p><p>Debug 常用快捷键</p><p>快捷键介绍</p><p>F7在Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中必备</p><p>F8在Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内必备</p><p>F9在Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上必备</p><p>Alt + F8在Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果必备</p><p>Ctrl + F8在Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</p><p>Shift + F7在Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</p><p>Shift + F8在Debug 模式下，跳出，表现出来的效果跟F9 一样</p><p>Ctrl + Shift + F8在Debug 模式下，指定断点进入条件</p><p>Alt + Shift + F7在Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</p><p>Idea 常用十大快捷键</p><ol><li>智能提示</li></ol><p>Intellij首当其冲的当然就是Intelligence 智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。</p><p>最后要说一点，Intellij能够智能感知spring、hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。</p><ol><li>重构</li></ol><p>Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。</p><p>切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。</p><ol><li>代码生成</li></ol><p>这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。</p><p>另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。</p><ol><li>编辑</li></ol><p>编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+折叠代码就不多说了。</p><p>关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p><ol><li>查找打开</li></ol><p>类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。</p><p>类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。</p><p>要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。</p><p>Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。</p><ol><li>其他辅助</li></ol><p>以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p><p>Ø命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。</p><p>Ø新建：Alt+Insert可以新建类、方法等任何东西。</p><p>Ø格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。</p><p>Ø切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-​​运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。</p><p>Ø单元测试：Ctrl+Alt+T创建单元测试用例。</p><p>Ø运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。</p><p>Ø调试：F7/F8/F9分别对应Step into，Step over，Continue。</p><p>此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。</p><ol><li>最终榜单</li></ol><p>这榜单阵容太豪华了，后几名都是如此有用，毫不示弱。</p><p>ØTop #10切来切去：Ctrl+Tab</p><p>ØTop #9选你所想：Ctrl+W</p><p>ØTop #8代码生成：Template/Postfix +Tab</p><p>ØTop #7发号施令：Ctrl+Shift+A</p><p>ØTop #6无处藏身：Shift+Shift</p><p>ØTop #5自动完成：Ctrl+Shift+Enter</p><p>ØTop #4创造万物：Alt+Insert<br>太难割舍，前三名并列吧！</p><p>ØTop #1智能补全：Ctrl+Shift+Space</p><p>ØTop #1自我修复：Alt+Enter</p><p>ØTop #1重构一切：Ctrl+Shift+Alt+T</p>]]></content>
      
      <categories>
          
          <category> android studio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017.01.01</title>
      <link href="/2017/01/01/2017-01-01/"/>
      <content type="html"><![CDATA[<p>没什么，只是说说而已。<br>感激似曾拥有，感谢获得重生。<br>没什么比懂自己的心来得更重要。</p>]]></content>
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2016</title>
      <link href="/2016/12/31/2016/"/>
      <content type="html"><![CDATA[<p>妥协生活<br>妥协工作<br>妥协感情<br>我得到了什么，又失去了什么。</p>]]></content>
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二零一六年总结</title>
      <link href="/2016/12/28/%E4%BA%8C%E9%9B%B6%E4%B8%80%E5%85%AD%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<p>1.情感优先于思考选择跳槽去了朋友公司。<br>2.对问题的思考程度不是很慎重。<br>3.太过于注重自己在熟人的位置。<br>4.该经历的总会经历，该放下也会放下。<br>5.以上都是屁话。</p>]]></content>
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android开发要避免的那些坑</title>
      <link href="/2016/11/07/android%E5%BC%80%E5%8F%91%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangke3016/article/details/51831122" target="_blank" rel="noopener">android开发要避免的那些坑</a></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rxjava操作符</title>
      <link href="/2016/11/02/rxjava%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <content type="html"><![CDATA[<p>操作符决策树</p><p>直接创建一个Observable（创建操作） 组合多个Observable（组合操作） 对Observable发射的数据执行变换操作（变换操作） 从Observable发射的数据中取特定的值（过滤操作） 转发Observable的部分值（条件/布尔/过滤操作） 对Observable发射的数据序列求值（算术/聚合操作）<br>创建操作<br><a id="more"></a><br>用于创建Observable的操作符<br>Create<br>通过调用观察者的方法从头创建一个Observable<br>Empty/Never/Throw<br>创建行为受限的特殊Observable<br>Defer<br>在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable<br>Just<br>将对象或者对象集合转换为一个会发射这些对象的Observable<br>From<br>将其它的对象或数据结构转换为Observable<br>Range<br>创建发射指定范围的整数序列的Observable,range操作符,发射从start开始的count个数<br>Interval<br>间隔一定时间发送一个数字,从0开始.本身运行在Schedulers.computation() 线程内<br>Repeat<br>Repeat作用在Observable上,会对其重复发射count次<br>Timer<br>Timer会在指定时间后发射一个数字0，注意其也是运行在computation Scheduler<br>变换操作</p><p>对Observable发射的数据进行变，能将数据转化为我们想要的格式，<br>Buffer<br>缓存，可以简单的理解为缓存，它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个<br>FlatMap<br>扁平映射，将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，可以认为是一个将嵌套的数据结构展开的过程。<br>GroupBy<br>分组，将原来的Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据<br>Map<br>映射，通过对序列的每一项都应用一个函数变换Observable发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项<br>Scan<br>扫描， 连续地对数据序列的每一项应用一个函数，然后连续发射结果,每一项结果基于之前的结果.累加器函数.<br>Window<br>窗口，定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。类似于Buffer，但Buffer发射的是数据，Window发射的是Observable，每一个Observable发射原始Observable的数据的一个子集<br>toList<br>Returns an Observable that emits a single item, a list composed of all the items emitted by the source Observable. 将一个Observable转换为一个List.<br>过滤操作</p><p>滤掉数据集合中我们不想要的数据。用于从Observable发射的数据中进行选择。<br>throttleWithTimeout<br>源Observable每次发射出来一个数据后就会进行计时,如果在设定好的时间结束前源Observable有新的数据发射出来，这个数据就会被丢弃，同时重新开始计时。<br>Debounce<br>只有在空闲了一段时间后才发射数据，通俗的说，就是如果一段时间没有操作，就执行一次操作.还可以根据一个函数来进行限流。这个函数的返回值是一个临时Observable，<br>如果源Observable在发射一个新的数据的时候，上一个数据根据函数所生成的临时Observable还没有结束,没有调用onComplete，那么上一个数据就会被过滤掉。如果是最后一个,还是会发射.<br>Distinct<br>去重，过滤掉所有的重复数据项<br>DistinctUtilChanged<br>过滤掉相邻的重复项<br>ElementAt<br>取值，取特定位置的数据项<br>Filter<br>过滤，过滤掉没有通过谓词测试的数据项，只发射通过测试的<br>First<br>取满足条件的第一个,如无满足条件数据抛出异常.可以使用takeFisrt(),仅会调动onComplete.<br>有null数据时会抛空指针异常,要判空处理.<br>只取满足条件的第一个数据.可以和BlockingObservable连用。可以Observable.toBlocking或者BlockingObservable.from方法来将一个Observable对象转化为BlockingObservable对象<br>Last<br>末项，只发射最后一条数据.<br>IgnoreElements<br>忽略所有的数据，只保留终止通知(onError或onCompleted)<br>Sample<br>取样，定期发射最新的数据，等于是数据抽样，有的实现里叫ThrottleFirst<br>throttleFirst<br>会定期发射这个时间段里源Observable发射的第一个数据<br>Skip<br>跳过前面的若干项数据<br>SkipLast<br>跳过后面的若干项数据<br>Take<br>只保留前面的若干项数据<br>TakeLast<br>只保留后面的若干项数据<br>takeFirst<br>有null数据时会抛空指针异常,要判空处理<br>和first一样，但在所有数据不满足条件时不会抛出异常，仅仅调用onComplete.<br>组合操作</p><p>And/Then/When<br>通过模式(And条件)和计划(Then次序)组合两个或多个Observable发射的数据集<br>CombineLatest<br>当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果<br>必须满足两个条件:<br>1)所有的Observable都发射过数据。<br>2)满足条件1的时候任何一个Observable发射一个数据，就将所有Observable最新发射的数据按照提供的函数组装起来发射出去。<br>在这两个条件下,可能会忽略掉一些发射的数据.<br>Join<br>无论何时，如果一个Observable发射了一个数据项，只要在另一个Observable发射的数据项定义的时间窗口内，就将两个Observable发射的数据合并发射<br>参数说明:<br>1)源Observable所要组合的目标Observable<br>2)一个函数，就收从源Observable发射来的数据，并返回一个Observable，这个Observable的生命周期决定了源Observable发射出来数据的有效期<br>3)一个函数，就收从目标Observable发射来的数据，并返回一个Observable，这个Observable的生命周期决定了目标Observable发射出来数据的有效期<br>4)一个函数，接收从源Observable和目标Observable发射来的数据，并返回最终组合完的数据。<br>Merge<br>将两个Observable发射的数据组合并成一个<br>Merge可能会让合并的Observables发射的数据交错（可以使用Concat操作符,不会让数据交错，它会按顺序一个接着一个发射多个Observables的发射物）。<br>StartWith<br>在发射原来的Observable的数据序列之前，先发射一个指定的数据序列或数据项<br>在数据序列的开头插入一条指定的项<br>你也可以传递一个Observable给startWith，<br>它会将那个Observable的发射物插在原始Observable发射的数据序列之前.这可以看作是Concat的反转。<br>Switch，在RxJava的实现为SwitchOnNext<br>将一个发射Observable序列的Observable转换为这样一个Observable：它逐个发射那些Observable最近发射的数据<br>用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。<br>需要注意的就是，如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新的小Observable所发射的数据。<br>Zip<br>zip zipWith<br>打包，使用一个指定的函数将多个Observable发射的数据组合在一起，然后将这个函数的结果作为单项数据发射<br>Zip操作符将多个Observable发射的数据按顺序组合起来，每个数据只能组合一次，而且都是有序的。<br>最终组合的数据的数量由发射数据最少的Observable来决定。<br>错误处理</p><p>这些操作符用于从错误通知中恢复<br>Catch<br>捕获，继续序列操作，将错误替换为正常的数据，从onError通知中恢复<br>onErrorReturn<br>当发生错误的时候，让Observable发射一个预先定义好的数据并正常地终止,不会抛出异常 onErrorResumeNext<br>当发生错误的时候，由另外一个Observable来代替当前的Observable并继续发射数据 onExceptionResumeNext<br>类似于OnErrorResume,不同之处在于其会对onError抛出的数据类型做判断，<br>如果是Exception，也会使用另外一个Observable代替原Observable继续发射数据，<br>否则会将错误分发给Subscriber。<br>Retry<br>重试，如果Observable发射了一个错误通知，重新订阅它，期待它正常终止<br>retry<br>Retry操作符在发生错误的时候会重新进行订阅,而且可以重复多次，<br>所以发射的数据可能会产生重复。如果重复指定次数还有错误的话就会将错误返回给观察者,会掉onError retryWhen<br>当错误发生时，retryWhen会接收onError的throwable作为参数，并根据定义好的函数返回一个Observable，如果这个Observable发射一个数据，就会重新订阅。<br>需要注意的是使用retryWhen的时候,因为每次重新订阅都会产生错误，所以作为参数的obserbvable会不断地发射数据，使用zipWith操作符可以限制重新订阅的次数，否则会无限制地重新订阅。<br>会正常结束,调用onCompleted<br>辅助操作</p><p>Delay<br>延迟一段时间发射结果数据<br>DelaySubscription<br>延迟注册到Observer上<br>Do<br>Do操作符就是给Observable的生命周期的各个阶段加上一系列的回调监听，当Observable执行到这个阶段的时候，这些回调就会被触发.<br>doOnEach<br>Observable每发射一个数据的时候就会触发这个回调，不仅包括onNext还包括onError和onCompleted。<br>doOnNext<br>只有onNext的时候才会被触发。<br>doOnSubscribe,doOnUnSubscribe<br>会在Subscriber进行订阅和反订阅的时候触发回调。<br>当一个Observable通过OnError或者OnCompleted结束的时候，会反订阅所有的Subscriber。在Android中和生命周期绑定起来,因为有些Observable执行不完啊.<br>doOnSubscribeOn<br>在开始注册前做一些工作。处于当前线程，而不是subscribeOn指定的线程。<br>DoOnError<br>在OnError发生的时候触发回调，并将Throwable对象作为参数传进回调函数里。<br>DoOnComplete<br>会在OnCompleted发生的时候触发回调。<br>DoOnTerminate<br>会在Observable结束前触发回调，无论是正常还是异常终止。<br>finallyDo,doAfterTerminate<br>会在Observable结束后触发回调，无论是正常还是异常终止。<br>Materialize,dematerialize<br>Meterialize操作符将OnNext/OnError/OnComplete都转化为一个Notification对象并按照原来的顺序发射出来,dematerialize相反<br>使用integerNotification.getValue() +”, ” + integerNotification.getKind()可以看到打印值和类型.<br>ObserveOn<br>指定Subscriber的调度程序（工作线程）<br>SubscribeOn<br>指定Observable应该在哪个调度程序上执行<br>Serialize<br>强制Observable按次序发射数据并且功能是有效的<br>Subscribe<br>收到Observable发射的数据和通知后执行的操作<br>TimeInterval<br>将一个Observable转换为发射两个数据之间所耗费时间的Observable<br>TimeInterval会拦截发射出来的数据，取代为前后两个发射两个数据的间隔时间。对于第一个发射的数据，其时间间隔为订阅后到首次发射的间隔。<br>Timeout<br>添加超时机制，如果过了指定的一段时间没有发射数据，就发射一个错误通知<br>Timeout操作符给Observable加上超时时间，每发射一个数据后就重置计时器，当超过预定的时间还没有发射下一个数据，就抛出一个超时的异常。<br>Rxjava将Timeout实现为很多不同功能的操作符，比如说超时后用一个备用的Observable继续发射数据等。<br>Timestamp<br>给Observable发射的每个数据项添加一个时间戳<br>TimeStamp会将每个数据项给重新包装一下，加上了一个时间戳来标明每次发射的时间<br>Using<br>创建一个只在Observable的生命周期内存在的一次性资源<br>Using操作符创建一个在Observable生命周期内存活的资源，也可以这样理解：<br>我们创建一个资源并使用它，用一个Observable来限制这个资源的使用时间，当这个Observable终止的时候，这个资源就会被销毁。<br>Using需要使用三个参数，分别是：<br>1)创建这个一次性资源的函数<br>2)创建Observable的函数<br>3)释放资源的函数<br>条件和布尔操作</p><p>这些操作符可用于单个或多个数据项，也可用于Observable<br>All<br>判断Observable发射的所有的数据项是否都满足某个条件<br>All操作符根据一个函数对源Observable发射的所有数据进行判断，最终返回的结果就是这个判断结果。<br>对发射的所有数据应用这个函数,如果全部都满足则返回true，否则就返回false。<br>Amb<br>Amb操作符可以将至多9个Observable结合起来，让他们竞争。<br>哪个Observable首先发射了数据（包括onError和onComplete)就会继续发射这个Observable的数据，其他的Observable所发射的数据都会别丢弃。<br>Contains<br>判断Observable是否会发射一个指定的数据项<br>Contains操作符用来判断源Observable所发射的数据是否包含某一个数据，如果包含会返回true，如果源Observable已经结束了却还没有发射这个数据则返回false。<br>IsEmpty<br>IsEmpty操作符用来判断源Observable是否发射过数据，没有发射过数据返回true.<br>Null也是一个数据<br>DefaultIfEmpty<br>发射来自原始Observable的数据，如果原始Observable没有发射数据，就发射一个默认数据<br>会判断源Observable是否发射数据，如果源Observable发射了数据则正常发射这些数据，如果没有则发射一个默认的数据<br>SequenceEqual<br>判断两个Observable是否按相同的数据序列<br>SequenceEqual操作符用来判断两个Observable发射的数据序列是否相同（发射的数据相同，数据的序列相同，结束的状态相同），如果相同返回true，否则返回false<br>SkipUntil<br>SkipUnitl是根据一个标志Observable来判断的，当这个标志Observable没有发射数据的时候，所有源Observable发射的数据都会被跳过；当标志Observable发射了一个数据，则开始正常地发射数据。<br>一直等到skipUntil发射了数据才能发射源Observable的数据,并忽略了此段时间内的数据<br>SkipWhile<br>SkipWhile则是根据一个函数来判断是否跳过数据，当函数返回值为true的时候则一直跳过源Observable发射的数据；当函数返回false的时候则开始正常发射数据。<br>TakeUntil<br>和SkipUtil恰好相反,只获取takeUntil里的Observable之前的数据<br>TakeWhile<br>和SkipWhile相反,获取满足skipWhile的数据<br>算术和聚合操作</p><p>Concat<br>将多个Observable结合成一个Observable并发射数据，并且严格按照先后顺序发射数据，前一个Observable的数据没有发射完，不发射后面Observable的数据<br>Count<br>Count操作符用来统计源Observable发射了多少个数据，最后将数目给发射出来；<br>如果源Observable发射错误，则会将错误直接报出来；在源Observable没有终止前，count是不会发射统计数据的。<br>Reduce<br>Reduce操作符应用一个函数接收Observable发射的数据和函数的计算结果作为下次计算的参数，输出最后的结果。<br>跟前面我们了解过的scan操作符很类似，只是scan会输出每次计算的结果，而reduce只会输出最后的结果。<br>Collect<br>collect用来将源Observable发射的数据给收集到一个数据结构里面，需要使用两个参数：<br>一个产生收集数据结构的函数<br>一个接收第一个函数产生的数据结构和源Observable发射的数据作为参数的函数。<br>连接操作</p><p>一些有精确可控的订阅行为的特殊Observable<br>什么是Connectable Observable:<br>就是一种特殊的Observable对象，并不是Subscrib的时候就发射数据，而是只有对其应用connect操作符的时候才开始发射数据，<br>所以可以用来更灵活的控制数据发射的时机。<br>使用Publish操作符将Observable转换为Connectable Observable,然后可以通过connect控制何时发射.<br>Publish<br>将一个普通的Observable转换为可连接的<br>Publish操作符就是用来将一个普通的Observable对象转化为一个Connectable Observable。需要注意的是如果发射数据已经开始了再进行订阅只能接收以后发射的数据。<br>Connect<br>Connect操作符就是用来触发Connectable Observable发射数据的。<br>应用Connect操作符后会返回一个Subscription对象，通过这个Subscription对象，我们可以调用其unsubscribe方法来终止数据的发射。<br>另外，如果还没有订阅者订阅的时候就应用Connect操作符也是可以使其开始发射数据的。<br>RefCount<br>RefCount操作符就是将一个Connectable Observable 对象再重新转化为一个普通的Observable对象，这时候订阅者进行订阅时就会触发数据的发射。<br>Replay<br>Replay操作符返回一个Connectable Observable 对象并且可以缓存其发射过的数据，这样即使有订阅者在其发射数据之后进行订阅也能收到其之前发射过的数据。<br>不过使用Replay操作符我们最好还是限定其缓存的大小，否则缓存的数据太多了可会占用很大的一块内存。<br>对缓存的控制可以从空间和时间两个方面来实现。<br>直接返回一个connectable observable,不用publish<br>转换操作</p><p>to<br>自定义操作符</p><p>lift compose</p><p><a href="http://blog.csdn.net/zhupumao/article/details/51932850" target="_blank" rel="noopener">rxjava汇总链接</a></p>]]></content>
      
      <categories>
          
          <category> rxjava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> rxjava </tag>
            
            <tag> rxandroid </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tinker[微信]热更新</title>
      <link href="/2016/11/02/Tinker%5B%E5%BE%AE%E4%BF%A1%5D%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
      <content type="html"><![CDATA[<p>现在市面上有很多热更新的开源比如：Tinker、QZone、Andfix、Robust<br>比较<br><img src="/2016/11/02/Tinker[微信]热更新/../../../../images/20180426104055.png" alt="Alt text"><br> <a href="https://blog.csdn.net/hao_m582/article/details/78694439" target="_blank" rel="noopener">https://blog.csdn.net/hao_m582/article/details/78694439</a></p>]]></content>
      
      <categories>
          
          <category> tinker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android常用的算法</title>
      <link href="/2016/11/01/android%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95/"/>
      <content type="html"><![CDATA[<blockquote><p> 1.插入排序算法</p></blockquote><pre><code>插入排序的基本思想是在遍历数组的过程中，假设在序号 i 之前的元素即 [0..i-1] 都已经排好序，本趟需要找到 i 对应的元素 x 的正确位置 k ，并且在寻找这个位置 k 的过程中逐个将比较过的元素往后移一位，为元素 x “腾位置”，最后将 k 对应的元素值赋为 x ，一般情况下，插入排序的时间复杂度和空间复杂度分别为 O(n2 ) 和 O(1)。public int []  sortInsert(int[] array){        for(int i = 1 ; i &lt; array.length; i++){            int temp = array[i];            int j ;            for ( j = i - 1; j &gt;= 0 &amp;&amp; temp &lt; array[j] ; j--){                array[ j + 1 ] = array[j];               }            array[ j + i ] = temp;        }        return array;}</code></pre><blockquote><p>2.选择排序算法</p></blockquote><pre><code>选择排序的基本思想是遍历数组的过程中，以 i 代表当前需要排序的序号，则需要在剩余的 [i…n-1] 中找出其中的最小值，然后将找到的最小值与 i 指向的值进行交换。因为每一趟确定元素的过程中都会有一个选择最大值的子流程，所以人们形象地称之为选择排序。选择排序的时间复杂度和空间复杂度分别为 O(n2 ) 和 O(1) 。public int[] sortSelect(int[] arr){  for (int i = 0; i &lt; arr.length; i++) {        int miniPost = i;        for (int m = i + 1; m &lt; arr.length; m++) {              if (arr[m] &lt; arr[miniPost]) {                    miniPost = m;              }        }        if (arr[i] &gt; arr[miniPost]) {              int temp;              temp = arr[i];              arr[i] = arr[miniPost];              arr[miniPost] = temp;       }  }  return arr;</code></pre><p> }</p><blockquote><p>3.冒泡排序算法</p></blockquote><pre><code>冒泡排序是將比較大的數字沉在最下面，较小的浮在上面public int[] sortBubble(int[] array){ int temp; // 第一层循环:表明比较的次数, 比如 length 个元素,比较次数为 length-1 次（肯定不需和自己比） for(int i=0;i&lt;array.length-1;i++){      for (int j = array.length - 1; j &gt; i; j--) {            if (array[j] &lt; array[j - 1]) {                 temp = array[j];                 array[j] = array[j - 1];                 array[j - 1] = temp;            }      } } return array;</code></pre><blockquote><p>4.快速排序算法</p></blockquote><pre><code>通过一趟排序将待排记录分割成独立的两部分,其中一部分记录的关键字均比另一部分的关键字小,则可以分别对这两部分记录继续进行排序,已达到整个序列有序的目的，本质就是,找一个基位(枢轴,分水岭,作用是左边的都比它小,右边的都比它大.可随机,取名base，首先从序列最右边开始找比base小的,如果小,换位置,从而base移到刚才右边(比较时比base小)的位置(记为临时的high位),这样base右边的都比base大。然后,从序列的最左边开始找比base大的，如果大,换位置,从而base移动到刚才左边(比较时比base大)的位置(记为临时的low位),这样base左边的都比base小，循环以上两步,直到 low == heigh, 这使才真正的找到了枢轴,分水岭. 返回这个位置,分水岭左边和右边的序列,分别再来递归。public int[] sortQuick(int[] array){ return quickSort(array, 0, array.length-1);}private int[] quickSort(int[] arr, int low, int heigh) {  if (low &lt; heigh) {       int division = partition(arr, low, heigh);       quickSort(arr, low, division - 1);       quickSort(arr, division + 1, heigh);  }  return arr;}</code></pre><p>// 分水岭,基位,左边的都比这个位置小,右边的都大    </p><pre><code>private int partition(int[] arr, int low, int heigh) {  int base = arr[low]; //用子表的第一个记录做枢轴(分水岭)记录  while (low &lt; heigh) { //从表的两端交替向中间扫描        while (low &lt; heigh &amp;&amp; arr[heigh] &gt;= base) {             heigh--;        }        // base 赋值给 当前 heigh 位,base 挪到(互换)到了这里,heigh位右边的都比base大        swap(arr, heigh, low);        while (low &lt; heigh &amp;&amp; arr[low] &lt;= base) {              low++;        }        // 遇到左边比base值大的了,换位置        swap(arr, heigh, low);  }  // now low = heigh;  return low;  }    private void swap(int[] arr, int a, int b) {          int temp;          temp = arr[a];          arr[a] = arr[b];          arr[b] = temp;  }</code></pre><blockquote><p>5.合并排序算法</p></blockquote><p>归并排序采用的是递归来实现，属于“分而治之”，将目标数组从中间一分为二，之后分别对这两个数组进行排序，排序完毕之后再将排好序的两个数组“归并”到一起，归并排序最重要的也就是这个“归并”的过程，归并的过程中需要额外的跟需要归并的两个数组长度一致的空间</p><pre><code>private int[] sort(int[] nums, int low, int high) {  int mid = (low + high) / 2;  if (low &lt; high) {      // 左边      sort(nums, low, mid);      // 右边      sort(nums, mid + 1, high);      // 左右归并      merge(nums, low, mid, high); } return nums; } private void merge(int[] nums, int low, int mid, int high) {      int[] temp = new int[high - low + 1];      int i = low;// 左指针      int j = mid + 1;// 右指针      int k = 0;      // 把较小的数先移到新数组中      while (i &lt;= mid &amp;&amp; j &lt;= high) {          if (nums[i] &lt; nums[j]) {               temp[k++] = nums[i++];          } else {               temp[k++] = nums[j++];          }      }      // 把左边剩余的数移入数组      while (i &lt;= mid) {           temp[k++] = nums[i++];      }      // 把右边边剩余的数移入数组      while (j &lt;= high) {           temp[k++] = nums[j++];      }      // 把新数组中的数覆盖nums数组      for (int k2 = 0; k2 &lt; temp.length; k2++) {           nums[k2 + low] = temp[k2];      }  }  public int[] sortMerge(int[] array) {         return sort(array, 0, array.length - 1); }</code></pre><blockquote><p>6.希尔排序算法</p></blockquote><p>希尔排序的诞生是由于插入排序在处理大规模数组的时候会遇到需要移动太多元素的问题。希尔排序的思想是将一个大的数组“分而治之”，划分为若干个小的数组，以 gap 来划分，比如数组 [1, 2, 3, 4, 5, 6, 7, 8] ，如果以 gap = 2 来划分，可以分为 [1, 3, 5, 7] 和 [2, 4, 6, 8] 两个数组（对应的，如 gap = 3 ， 则划分的数组为： [1, 4, 7] 、 [2, 5, 8] 、 [3, 6] ）然后分别对划分出来的数组进行插入排序，待各个子数组排序完毕之后再减小 gap 值重复进行之前的步骤，直至 gap = 1 ，即对整个数组进行插入排序，此时的数组已经基本上快排好序了，所以需要移动的元素会很小很小，解决了插入排序在处理大规模数组时较多移动次数的问题，</p><p>希尔排序是插入排序的改进版，在数据量大的时候对效率的提升帮助很大，数据量小的时候建议直接使用插入排序就好了。</p><pre><code>public int[] sortShell(int[] array) { // 取增量 int step = array.length / 2; while (step &gt;= 1) {      for (int i = step; i &lt; array.length; i++) {           int temp = array[i];           int j = 0;           // 跟插入排序的区别就在这里           for (j = i - step; j &gt;= 0 &amp;&amp; temp &lt; array[j]; j -= step) {                 array[j + step] = array[j];           }           array[j + step] = temp;      }      step /= 2;     }     return array; }</code></pre><blockquote><p>7.堆排序算法</p></blockquote><p>本质就是先构造一个大顶堆,parent比children大,root节点就是最大的节点 把最大的节点(root)与尾节点(最后一个节点,比较小)位置互换，剩下最后的尾节点,现在最大,其余的,从第一个元素开始到尾节点前一位,构造大顶堆递归。</p><pre><code>public int[] sortHeap(int[] array) { buildHeap(array);// 构建堆 int n = array.length; int i = 0; for (i = n - 1; i &gt;= 1; i--) {      swap(array, 0, i);      heapify(array, 0, i); } return array; }private void buildHeap(int[] array) {     int n = array.length;// 数组中元素的个数        for (int i = n / 2 - 1; i &gt;= 0; i--)          heapify(array, i, n);}private void heapify(int[] A, int idx, int max) {      int left = 2 * idx + 1;// 左孩子的下标（如果存在的话）      int right = 2 * idx + 2;// 左孩子的下标（如果存在的话）      int largest = 0;// 寻找3个节点中最大值节点的下标      if (left &lt; max &amp;&amp; A[left] &gt; A[idx])            largest = left;      else            largest = idx;      if (right &lt; max &amp;&amp; A[right] &gt; A[largest])            largest = right;            if (largest != idx) {                  swap(A, largest, idx);                  heapify(A, largest, max);            }      }  }</code></pre><p>// 建堆函数，认为【s，m】中只有 s<br>// 对应的关键字未满足大顶堆定义，通过调整使【s，m】成为大顶堆=====================================================</p><pre><code>public static void heapAdjust(int[] array, int s, int m) {      // 用0下标元素作为暂存单元      array[0] = array[s];      // 沿孩子较大的结点向下筛选      for (int j = 2 * s; j &lt;= m; j *= 2) {            // 保证j为较大孩子结点的下标，j &lt; m 保证 j+1 &lt;= m ，不越界            if (j &lt; m &amp;&amp; array[j] &lt; array[j + 1]) {                   j++;            }            if (!(array[0] &lt; array[j])) {                   break;            }            // 若S位较小，应将较大孩子上移            array[s] = array[j];            // 较大孩子的值变成S位的较小值，可能引起顶堆的不平衡，故对其所在的堆进行筛选            s = j;      }      // 若S位较大，则值不变；否则，S位向下移动至2*s、4*s、。。。      array[s] = array[0];}</code></pre>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一路走来</title>
      <link href="/2016/11/01/%E4%B8%80%E8%B7%AF%E8%B5%B0%E6%9D%A5/"/>
      <content type="html"><![CDATA[<blockquote><p>2014.07.10-12</p></blockquote><p>坐绿皮火车卧铺，学校同班几个伙伴，说说笑笑，经历两天的时间，抵达了梦寐已久的之都，深圳。【因为两年前的我，曾经说一句话，我毕业后第一站就是深圳。】</p><blockquote><p>2014.07.15-25</p></blockquote><p>那时的我们还带着学校的稚气，未毕业就踏入社会之门，我们以为社会应该跟学校差不多，其实错了，一开始我们以毕业生的姿态，拿着不是很起眼的学历，奔波于地铁、公交， 不断的求职，在一次一次挫折后，我们开始披上社会的面具，伪造假学历，毕业证书，说着不太切实际的话，职位才向我们敞开大门。这是我的第一份工作太突然，做了两个星期就离开，那时的我没自信，恐惧，加上没钱了跟爸妈提拿钱时，倒出了自己的离职，也被说一顿。</p><blockquote><p>2014.07.15-2015.06.31</p></blockquote><p>从上家公司离职后，突然大病一场，带着病找了一周时间，没找到面试的工作机会，那时真的很失望。这时同班的同学介绍我去她公司面试，我带自己的简历与在学校做的作品，终于敲开了入职之门。这是我的入职二家公司呆了一年。这里年的时间里，我学到很多很多东西，也是最深刻的一年，经历太多，种种原因，坚持到了合同结束，没有想过续签合同的就走了。</p><blockquote><p>2015.07.04-2016.06.31</p></blockquote><p>第三家公司，面试了几天两个off，第一个off，是早上去同学公司面试。第二个off下午自己找到的公司，这家也是我一年多以来最自信，最爽快的面试经历。在一天的考虑之中。最终还是去了同学的公司。然而没呆到合同结束就走人了。非常感谢自己的上司热情款待，部门老大的教育，带我们疯，带我们闹。</p><blockquote><p>2016.7.-至今</p></blockquote><p>第四家公司，突然来到这家公司是跳槽过来的，上家公司环境，待遇算可以，但是公司的产品迭代太慢，闲就是一个月以上，考虑一个星期多。最后还是选择跳槽来到了这家公司就为了两点，未接触过的技术点。待遇提升。</p>]]></content>
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dagger2mvp架构使用</title>
      <link href="/2016/10/31/dagger2mvp%E6%9E%B6%E6%9E%84%E4%BD%BF%E7%94%A8/"/>
      <content type="html"><![CDATA[<p>了解请点击<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html" target="_blank" rel="noopener">dagger2基础了解</a></p><p>dagger2使用教程：<br>    根目录的build文件加入android-apt支持</p><pre><code>环境配置：buildscript{    repositories{        jcenter()    }}dependencies{    classpath &apos;com.android.tools.build:gradle:x.x.x&apos;    classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.4&apos;}在app目录的build文件加入 apt plugin的支持plugin : &apos;com.neenbeankt.android-apt&apos; 加入dagger2 retrofit okhttp依赖 compile &apos;com.google.dagger:dagger:2.0&apos; apt &apos;com.google.dagger:dagger-compiler:2.0&apos; provided &apos;org.glassfish:javax.annotation:10.0-b28&apos; 在Application中实践Dagger2 现在依赖已经加入，开始动手使用Dagger2，第一步考虑我们Application。 先创建AppApplication，并在AndroidMainfest.xml 注册好。public class AppApplication extends Application{    public void onCreate(){        super.onCreate();    }}&lt;application   android:name=&quot;.AppApplication&quot;   android:allowBackuo=&quot;true&quot;   android:icon=&quot;@mipmap/ic_lacuncher&quot;   android:label=&quot;@string/app_name&quot;   android:label=&quot;@string/app_name&quot;   /&gt;</code></pre>]]></content>
      
      <categories>
          
          <category> mvp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> mvp </tag>
            
            <tag> dagger2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android断点调试</title>
      <link href="/2016/10/31/android%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
      <content type="html"><![CDATA[<p> Android Studio包含一个debugger程序,可以帮助你在模拟器和真机上调试你的android应用.通过Android Studio的debugger,你可以:</p><p>1.选择你想调试的设备.<br>2.在代码上设置断点.<br>3.在运行时去检查变量和表达式的值.<br>可能平时大家调试代码都是通过打印log的形式,今天带大家走进断点调试的世界.</p><p>断点调试-基础篇<br>设置断点<br>设置断点的方法: 左键在需要调试的代码所处的侧边栏处单击.如下图所示: </p><p><img src="/2016/10/31/android断点调试/../../../../images/20160628204032573.png" alt="Alt text"><br>开始调试<br>点击红色箭头指向的按钮,即可进行代码调试,如下图所示:<br><img src="/2016/10/31/android断点调试/../../../../images/20160628204300199.png" alt="Alt text"><br>调试界面如下所示:<br><img src="/2016/10/31/android断点调试/../../../../images/20160628204824333.png" alt="Alt text"><br>单步调试<br>Step Over(F6)<br>代表程序直接执行当前行代码.(ps:如果该行是函数调用,则直接执行完函数的全部代码)<br><img src="/2016/10/31/android断点调试/../../../../images/20160628205544518.png" alt="Alt text"><br>Step Into(F5)<br>代表程序执行当前行代码(ps:如果该行有自定义方法,则运行进入自定义方法,不会进入官方类库的方法)<br><img src="/2016/10/31/android断点调试/../../../../images/20160628210031943.png" alt="Alt text"><br>具体效果如下:<br><img src="/2016/10/31/android断点调试/../../../../images/20160628210222255.png" alt="Alt text"><br>Step Out(F7)<br>跳出Step Into进入的方法.例如我们感觉进入的方法没有问题,不需要执行后续代码,就可以通过Step Out跳出当前进入的代码.<br><img src="/2016/10/31/android断点调试/../../../../images/20160628210902909.png" alt="Alt text"></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> mvp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>androidMVP架构模式</title>
      <link href="/2016/10/31/androidmvp%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<p>android MVP模式在Android项目中的使用</p><p>在开发当中我们会涉及到一些架构模式，对于初级程序员来说是很陌生，但是对于中级过渡高级的程序员来说是非常重要需要了解的模式。首先我们先了解有哪些架构模式：不管都前端，移动端，后端都会涉及到这三种：MVC、MVP、MVVM。<br>概念：什么是MVP<br>MVP是模型(Model)、视图(View)、主持人(Presenter)的缩写,分别代表项目中3个不同的模块。<br>模型(Model):负责处理数据的加载或者存储，比如从网络或者本地数据库获取数据等；<br>视图(View):负责界面数据的展示，与用户进行交互；<br>主持人(Presenter):相当于协调者，是模型与视图之间的桥梁，将模型与视图分离开来。</p><p>如下图所示，View与Model并不直接交互，而是使用Presenter作为View与Model之间的桥梁。其中Presenter中同时持有View层以及Model层的Interface的引用，而View层持有Presenter层Ineterface的引用。当View层某个界面需要展示展示某些数据的时候，首先会调用Presenter层的某个接口，然后Presneter层会调用Model层请求数据，当Model层数据加载成功之后会调用Presenter层的回调方法通知Presenter层数据加载完毕，最后Presneter层再调用View层的接口将加载后的数据展示给用户。这就是Mvp模式的整个核心过程。<br><img src="http://images2015.cnblogs.com/blog/420264/201512/420264-20151223222959015-298327306.png" alt="此处输入图片的描述"></p><p>这样分层的好处就是大大减少了Model与View层之间的耦合度。一方面可以使得View层和Model层单独开发与测试，互不依赖。另一方面Model层可以封装复用，可以极大的减少代码量。当然，Mvp还有其他的一些优点。</p><p>  1.View层<br>    View层首页数据展示模块的组件是Activity，里面有一个RecycleView 布局如下：  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;android.support.v7.widget.RecyclerView        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;        android:id=&quot;@+id/recycle_view&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:scrollbars=&quot;vertical&quot;        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;        android:paddingTop=&quot;@dimen/card_margin&quot;&gt;    &lt;/android.support.v7.widget.RecyclerView&gt;</code></pre><p>首页列表模块主要展示从网络获取的首页列表信息，view层的接口大概需要如下方法：<br>(1)请求数据的过程中需要提示‘正在加载’的反馈信息给用户<br>(2)加载数据成功后，将加载得到的数据填充到RecycleView展示给用户<br>(3)加载数据成功后，将提示‘正在加载’反馈信息取消掉<br>(4)若加载数据失败，如网络连接、则需要给用户提示信息。 </p><pre><code>//业务接口public interface HomeContract {    interface View {       void onLoading();       void onError(String error);       void updateUI(XXX xxx);       void ToastMessage(String message);    }    interface Action extends IPresenter {        void requestHome(XXX... xxx);    }}//业务处理请求public class HomePresenter implements HomeContract.Action{        HomeContract.view view;        public HomePresenter(HomeContract.view view){                this.view =view;        }        @Override        pubublic void requestHome(XXX... xxx){                //请求网络数据处理业务层                 view.onLoading();                view.onError();                view.updateUI();                view.ToastMessage();        }}</code></pre><p>首页列表Activity中实现上述接口：</p><pre><code>public class HomeActivity extends AppCompatActivity implements HomeContract.view {  HomeContract.Action action;    @Override    public void onLoading(){            //提示加载信息    }    @Override    public void onError(String error){            //加载错误ui    }    @Override    public void updateUI(XXX xxx){            //更新UI数据    }    @Override    public void ToastMessage(String message){           //网络请求结束提示信息    }    @Override    public void onCreate(@Nullable Bundle savedInstanceState){        super.onCreate(savedInstanceState);        action = new HomePresenter(this);        action.requestHome(xx);    }}当用户打开首页界面时，就请求网络获取数据，初始化Presenter引用实例，调用Presenter层的requestHome接口，业务处理完毕后，调用相应的onLoading()、onError()、updateUI()、ToastMessage()方法处理不同逻辑。</code></pre>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> mvp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dagger2学习</title>
      <link href="/2016/10/28/dagger2%E5%AD%A6%E4%B9%A0/"/>
      <content type="html"><![CDATA[<blockquote><p>为什么使用依赖注入</p></blockquote><p><strong>使用依赖注入的可以带来以下好处：</strong></p><ol><li>依赖的注入和配置独立于组件之处。</li><li>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方式，而不是用大改代码库。</li><li>以来可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。<br><img src="http://www.jcodecraeer.com/uploads/20150519/1431999088123888.png" alt="此处输入图片的描述"></li></ol><blockquote><p>  基本特点</p></blockquote><ol><li>多个注入点:依赖，通过injected</li><li>多种绑定方法:以来，通过provided</li><li>多个modules:实现某种功能的绑定集合</li><li>多个对象图:实现一个范围的modules集合</li></ol><blockquote><p> 区别点</p></blockquote><ol><li>再也没有使用反射:图的验证、配置和预先设置都在编译的时候执行。</li><li>容易调试和可跟踪:完全具体地调用提供和创建的堆栈。</li><li>更过的性能:谷歌声称他们提高了13%的处理性能</li><li>代码混淆:使用派遣方法，就如同自己写的代码一样<br>当然素偶有这些很棒的特点都需要付出一个代价，那就是缺乏灵活性，例如：dagger2没用反射所有没有动态机制。</li></ol><blockquote><p>概念与注入</p></blockquote><ol><li>@Inject：通常在需要依赖的地方使用这个注解.换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</li><li>@Module：Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要的特征它们设计分区并组合在一起(比如说，在我们的app中可以有多个组成在一起的modules)。</li><li>@Provide：再modules中，我们定义的方法是用这哥注解，以此告诉dagger我们想要构造对象并提供这些依赖。</li><li>@Component:Components从根本上说就是一个注入器，也可以说是@Inject和@Modules的桥梁，它的主要作用就是连接这两个部分。Components可以提供所有定义了的类型的实例，比如：我们必须用@Componets注解一个借口然后列出所有的@Modules组成该组件，如果缺失了任何一块都在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。</li><li>@Scope:Scope可是非常的有用，dagger2可以通过自定义注解限定注解的作用域。</li><li>@Qualifier:当类的类型不足以鉴别一个依赖的时候，我们就可以使用这个注解表示。</li></ol><blockquote><p> 使用方式<br>app-&gt;build.gradle</p></blockquote><pre><code>apply plugin: &apos;com.neenbedankt.android-apt&apos;buildscript {  repositories {    jcenter()  }  dependencies {    classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.4&apos;  }}android {  ...}dependencies {  apt &apos;com.google.dagger:dagger-compiler:2.0&apos;  compile &apos;com.google.dagger:dagger:2.0&apos;  ...}</code></pre><p>如上所示，我们添加了编译和运行库，还有必不可少的apt插件，没有这插件，dagger可能不会正常工作，特别是在Android studio中。</p><blockquote><p>dagger2注解的使用方式</p></blockquote><ol><li>构造方法注入：在类的构造方法前面注入@Inject</li><li>成员变量注入：在类的成员变量(非私有)前面注解@Inject</li><li>函数方法注入：在函数前面注解@Inject</li></ol>]]></content>
      
      <categories>
          
          <category> dagger2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> dagger2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android基于HLS和TRMP协议的第三方SDK选择</title>
      <link href="/2016/10/28/android%E5%9F%BA%E4%BA%8EHLS%E5%92%8CTRMP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9SDK%E9%80%89%E6%8B%A9/"/>
      <content type="html"><![CDATA[<p>协议的详解网上资料都太多了，我就不赘述了。Android上3.0开始支持hls，但在4.0以后就支持的不太好了。而对rtmp来说，Android是默认不支持的。网上有一些第三方库支持这两种协议，下面就我找到的第三方库列出并做出比较。</p><ul><li>提到流播放就不得不提到 Vitamio .协议支持全面，嵌入项目简单，对个人开发者免费。项目地址:<br><a href="https://github.com/yixia/VitamioBundle" target="_blank" rel="noopener">https://github.com/yixia/VitamioBundle</a>.</li><li>B站开源出来的 ijkplayer<br>.项目维护及时，许多大公司都在用。网易云音乐，斗鱼TV，火猫TV等等，影响力可见一斑。支持RTMP，HLS。项目地址:<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">https://github.com/Bilibili/ijkplayer</a>.<br>七牛开源出来的 PLDroidPlayer. 这个是基于B站的 ijkplayer<br>进行二次开发的。项目维护也很及时，你去上边提issue，很快就会有人回复你。同样支持RTMP,HLS。继承步骤简单，有wiki，我现在用的就是这个;)<br>,但以后收不收费就不一定了。项目地址:<a href="https://github.com/pili-engineering/PLDroidPlayer" target="_blank" rel="noopener">https://github.com/pili-engineering/PLDroidPlayer</a>.</li><li>大牛直播出品的 SmarterStreaming.<br>个人使用免费，项目地址:<a href="https://github.com/daniulive/SmarterStreaming" target="_blank" rel="noopener">https://github.com/daniulive/SmarterStreaming</a>.</li><li><p>新浪开源出来的 sinavideo_playersdk.<br>完全免费，你甚至可以修改备注。不过只支持hls协议，定制简单。项目地址:<a href="https://github.com/SinaVDDeveloper/sinavideo_playersdk" target="_blank" rel="noopener">https://github.com/SinaVDDeveloper/sinavideo_playersdk</a>.</p><p><a href="http://isunxu.xyz/android/between-rtmp-and-hls-third-party-choice/" target="_blank" rel="noopener">原文地址</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 直播 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android视频播放总结</title>
      <link href="/2016/10/27/Android%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<blockquote><p>[Android] Android 视频播放总结</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VideoView</span><br></pre></td></tr></table></figure><p>VideoView 的使用非常简单，播放视频的步骤：</p><ol><li>在界面布局文件中定义VideoView组件，或在程序中创建VideoView组件</li><li>调用VideoView的如下两个方法来加载指定的视频：</li></ol><ul><li>setVideoPath(String path);加载path文件代表的视频</li><li>setVideoURL(Uri uri);加载uri所对应的视频</li></ul><ol><li>调用VideoView的start()、stop()、psuse()方法控制视频的播放<br><strong>Exoplayer</strong><br><a href="https://github.com/google/ExoPlayer.git" target="_blank" rel="noopener">ExoPlayer Git 地址</a></li></ol><p><strong>用法</strong><br>ExoPlayer开源项目包含了libray和示例：</p><ul><li>ExoPlayer library - 这部分是核心的库</li><li><p>Demo app - 这部分是演示怎么使用ExoPlayer<br>ExoPlayer库的核心类是ExoPlayer类。该类维护了播放器的全局状态。比如如何获取媒体数据，如何缓冲以及是怎样编码格式。</p><p>ExoPlayer基于MediaCodec和AudioTrack提供了默认的音视频的TrackRenderer实现。所有的renderers都需要SampleSource对象，Exoplayer从SampleSource获得media samples用于播放。下图展示了Exoplayer是如何配置组合这些组件用于播放音视频的。<br><img src="http://blog.qiji.tech/wp-content/uploads/2016/03/standard-model.png" alt="此处输入图片的描述"><br>ExoPlayer库提供了一些不同类型的SampleSource实例：</p><ul><li>ExtractorSampleSource – 用于 MP3，M4A，WebM，MPEG-TS 和 AAC；</li><li>ChunkSampleSource – 用于 DASH 和平滑流的播放；</li><li>HlsSampleSource – 用于 HLS 播放；</li></ul></li></ul><p> 在 ExoPlayer 的 Dome 中使用 DemoPlayer 对 ExoPlayer 进行了封装，并提供了使用上述几种 SampleSource 构建 TrackRenderer 的 Builder。</p><ul><li>SmoothStreamingRendererBuilder</li><li>DashRendererBuilder</li><li>ExtractorRendererBuilder<br>在使用的时候我们根据不同的需求创建对应的 RendererBuilder，然后将 RendererBuilder 传递给 DemoPlayer 然后调用 DemoPlayer 的 setPlayWhenReady 方法。</li></ul><p>优缺点</p><p>ExoPlayer 相较于 MediaPlayer 有很多很多的优点：</p><ul><li>支持动态的自适应流 HTTP (DASH) 和 平滑流，任何目前 MediaPlayer </li><li>支持的视频格式（同时它还支持 HTTP</li><li>直播(HLS)，MP4，MP3，WebM，M4A，MPEG-TS 和 AAC）。 支持高级的 HLS 特性，例如正确处理EXT-X-DISCONTINUITY 标签； </li><li>支持自定义和扩治你的使用场景。ExoPlayer 专门为此设计；</li><li>便于随着 App的升级而升级。因为 ExoPlayer是一个包含在你的应用中的库，对于你使用哪个版本有完全的控制权，并且你可以简单的跟随应用的升级而升级； </li><li>更少的适配性问题。</li></ul><p>ExoPlayer 的缺点：</p><ul><li>ExoPlayer 的音频和视频组件依赖 Android 的 MediaCodec 接口，该接口发布于 Android4.1（API 等级<br>16）。因此它不能工作于之前的Android 版本。</li></ul><p><strong>Vitamio</strong></p><p><a href="https://github.com/yixia/VitamioBundle.git" target="_blank" rel="noopener">Vitamio demo 地址</a></p><p><strong>用法</strong><br>Vitamio的使用步骤：  </p><ol><li>下载Vitamio库，并作为工程依赖。</li><li><p>在Activity的onCreate方法中添加如下代码，初始化Vitamio的解码器</p><p>@Override public void onCreate(Bundle icicle){</p><pre><code>super.onCreate(icicle)if(!LibsChecker.checkVitamioLibs(this))return ;</code></pre><p>}</p><ol><li>在AndroidMainfest.xml中声明InitActivity</li></ol><p><activity android:name="io.vov.vitamio.activity.InitActivity" android:configchanges="orientation|screenSize|smallestScreenSize|keyboard|keyboardHidden" android:launchmode="singleTop" android:theme="@android:style/Theme.NoTitleBar" android:windowsoftinputmode="stateAlwaysHidden"> </activity></p><ol><li>其余步骤和使用 Android 原生的 VideoView 是一样的。</li></ol></li></ol><p><strong>优点</strong></p><ul><li>强大、支持超多格式视频和网络视频播放</li><li>使用简单。调用非常简单，方便使用。</li></ul><p><strong>ijkplayer</strong> 【哔哔哩开源】<br><a href="https://github.com/Bilibili/ijkplayer.git" target="_blank" rel="noopener">ijkplayer 项目地址</a></p><p><strong>用法</strong><br>1.clone ijkplayer 项目到本地</p><p>2.编译 ijkplayer</p><p>下面是我的编译环境</p><ul><li>编译环境 Mac OS X 10.10.5</li><li>Android</li><li>NDK — android-ndk-r10e</li><li>Android Studio 1.3.1</li><li><p>Gradle 2.4<br>编译之前要安装 homebrew, git, yasm。</p><p> ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”<br>brew install git<br>brew install yasm</p></li></ul><p>配置 NDK</p><pre><code># add these lines to your ~/.bash_profile or ~/.profile# export ANDROID_SDK=&lt;your sdk path&gt;# export ANDROID_NDK=&lt;your ndk path&gt;</code></pre><p>clone 项目</p><pre><code>git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-android</code></pre><p>编译 ffmpeg    </p><pre><code>cd ijkplayer-android ./init-android.sh cd configrm module.shln -s module-default.sh module.shcd android/contrib./compile-ffmpeg.sh clean./compile-ffmpeg.sh all</code></pre><p>ffmpeg 编译通过后，编译 ijkplayer </p><pre><code>cd .../compile-ijk.sh all</code></pre><p>编译通过后在 android 目录下有 ijkplayer 文件夹，这个是 ijkplayer 的 demo。导入 Android Studio 即可。ijkplayer 的 demo 中提供了 IjkVideoView 类，它封装了 Android 原生的 MediaPlayer 、ExoPlayer 和 IjkMediaPlayer。可根据需要选择。</p><p><strong>优缺点</strong></p><ul><li>ijkplayer 最大的优点就是可以根据需要编译需要的解码器。在编译的时候通过 ln -s module-default.shmodule.sh 选择要编译的解码器。ijkplayer 在 config目录下提供了三种 module.sh 。也可自己修改module.sh 。</li><li>ijkplayer 的缺点是库太大。加入项目后会大大增加你的 APP 的大小。</li></ul>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android开发职位分类</title>
      <link href="/2016/10/24/Android%E5%BC%80%E5%8F%91%E8%81%8C%E4%BD%8D%E5%88%86%E7%B1%BB/"/>
      <content type="html"><![CDATA[<p><strong>Android开发职位分类</strong></p><blockquote><p>Android开发分三类：</p></blockquote><ol><li>驱动开发：需要熟悉Linux和C语言，了解嵌入式开发相关知识，最好有驱动开发经验；待遇普遍比后两类高。</li><li>Android系统开发：基于Android系统的源码进行修改，修复bug或者对系统进行深度定制，重新设计并实现用户交互，主要是修改Android java层框架和Android系统自带的应用。需要应聘者熟练掌握JAVA语言，有移动开发经验或者J2ME开发经验。</li><li>Android应用开发。<br>  前两类的工作一般是手机硬件制造商或者手机设计公司提供这些职位，如华为、中兴、魅族、联想Lephone；华为、中兴大多是做运营商定制，基本很少对系统层进行深度定制，主要是修改bug(Android系统每个版本都有大量的bug），做这一块不但积累对Android系统层的经验，而且也积累分析问题、解决问题的经验。<br>  Android应用开发这个职位，大部分PC软件或互联网公司已经或正在做Android平台的支持。<br>  对于没有JAVA经验的人，首先掌握J2SE，然后再学Android的应用开发。无论看书、看视频、上培训班最重要的都是练习。<br>  Android应用开发书籍推荐《Google Android开发入门与实战》、《Google Android SDK开发范例大全》这两本书。</li></ol><p>知识体系图<br><img src="http://s11.sinaimg.cn/mw690/001OQFNvgy6I1dfhI4Wea&amp;690" alt="知识体系图"><img src="http://s11.sinaimg.cn/mw690/001OQFNvgy6I1dfhI4Wea&amp;690" alt="Android 知识图谱"></p><blockquote><p>软件码工的修炼之路</p></blockquote><ol><li>一门语言的语法，SDK的常用API，算法与数据结构；有了上面的知识，再加上一点实践，再从网上找一些笔试题做几套，基本可以过笔试这一关。</li><li>编码规范、高性能编码经验技巧；要成为一个职业化的、专业化的程序员，首先要养成良好的习惯，良好的习惯从规范化的点滴日常工作开始。</li><li>熟练掌握IDE、常用</li><li>编程设计的原则；重点掌握面向对象的原则，如单一职责原则SRP、开放－封闭原则、替换原则LSP、依赖倒置原则DIP等。这些原则对后面内容理解的深入有很大帮助。不了解这些原则而去学设计模式会有空中楼阁、头重脚轻的感觉。</li><li>重构：重构是在不改变软件功能的前提下改善代码的设计以提高可维护性。修改代码或者优化代码都需要用到重构技术。</li><li>设计模式：基于一些常用的模式来学习如何使用设计模式。设计模式对于做框架开发的程序员比较有帮助。</li><li>代码重构的艺术：最重要、最难，看上去却最简单的功夫。修改别人的代码开始是功夫，优化就是艺术。</li><li>架构设计：这是步入殿堂必不可少的部分。</li><li>软件工程：从CMM到敏捷的转变，个人是比较推崇敏捷开发的。</li><li>质量管理：越往后越偏向管理了，开始是个人修炼，后面是站在组织、站在公司的角度来看软件。质量管理中有很多很好的理论和工具，不只可以应用到软件开发上，生活中也很有用的。</li></ol>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git分支管理策略</title>
      <link href="/2016/10/24/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/"/>
      <content type="html"><![CDATA[<p>Git分支管理策略</p><p>1.主要分支：master</p><pre><code>说明：代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支开发。</code></pre><p>2.开发分支：Develop</p><pre><code>说明：主分支只用来分布重大版本，日常开发应该在另一个分支完成。我们把开发用的分支，叫做Develop命令：1.开启分支：git checkout -b  develop master2.将develop分支发布到Master分支命令：#切换到Master分支 git checkout master #对Develop分支进行合并 git merge --no-ff develop -m&quot;合并分支信息&quot;</code></pre><p>3.临时分支：Feature/Release/Fixbug</p><pre><code>1.Feature 功能分支：主要开发特定某功能，从Develop分支上面分出来。开发完成后，要再并入Develop。 命名格式采用 feature-* 创建一个临时分支 git checkout -b feature-x develop 开发完成后，将功能分支合并到develop分支。 1.git checkout develop  2.git merge --no-ff feature-x -m&quot;合并分支信息&quot; 3.git branch -d feature-x2.Felease 预发分支：是指发布正式版之前（即合并到Master分支之前），我们可能需要一个预发布的版本进行测试。从Develop分支上面分出来。开发完成后，要再并入Develop和Master。命名格式采用 release-* 创建预发分支 git checkout -b release-1.2 develop 开发确认没问题后。 1.git checkout master 2.git merge --on-ff release-1.2 -m&quot;合并分支信息&quot; #对合并的生成的新节点，做一个标签 git tag -a 1.2  #再合并到develop分支： 1.git checkout develop  2.git merge --no-ff release-1.2 -m&quot;合并分支信息&quot; 3.git branch -d release-1.23.Fixbug  bug分支：软件正式发布后，难免会出现bug，就需要创建一个分支，进行bug修补。从Master分支上面分出来的。修补结束以后，在合并到Master和Develop分支。命名格式fixbug-*  创建bug分支 git checkout -b fixbug-0.1 master 修复结束后 合并到master分支 1.git checkout master 2.git merge  --no-ff fixbug-0.1 -m&quot;合并分支信息&quot;  3.git tag -a 0.1.1 #再合并到develop分支 1.git checkout develop 2.git merge --no-ff fixbug-0.1 -m&quot;合并分支信息&quot; 3.git branch -d fixbug-0.1    </code></pre>]]></content>
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gradle包含库出现的问题</title>
      <link href="/2016/10/21/gradle%E5%8C%85%E5%90%AB%E5%BA%93%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<p>Error:org.gradle.api.internal.changedetection.state.DefaultFileCollectionSnapshotter$FileCollectionSnapshotImpl cannot be cast to org.gradle.api.internal.changedetection.state.OutputFilesCollectionSnapshotter$OutputFilesSnapshot<br>Possible causes for this unexpected error include:<ul><li>Gradle’s dependency cache may be corrupt (this sometimes occurs after a network connection timeout.)<br><a href="syncProject">Re-download dependencies and sync project (requires network)</a></li><li>The state of a Gradle build process (daemon) may be corrupt. Stopping all Gradle daemons may solve this problem.<br><a href="stopGradleDaemons">Stop Gradle build processes (requires restart)</a></li><li>Your project may be using a third-party plugin which is not compatible with the other plugins in the project or the version of Gradle requested by the project.</li></ul>In the case of corrupt Gradle processes, you can also try closing the IDE and then killing all Java processes.</p><p> 我直接把根目录的build删除，.gradle个文件夹也删除，然后gradle文件夹里面的版本再次提升一下版本就好了 </p>]]></content>
      
      <categories>
          
          <category> gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vuforia知识</title>
      <link href="/2016/10/20/Vuforia%E7%9F%A5%E8%AF%86/"/>
      <content type="html"><![CDATA[<blockquote><p>Vuforia示例应用提供了九种应用展示，介绍主要特点和表现出基本功能</p></blockquote><p><strong>Image Targets （图像目标）</strong></p><p> 图像目标示例显示如何检测图像的目标和渲染在它上面的一个简单的3D对象。主要功能包括：</p><ol><li>同时检测和多目标跟踪</li><li>加载和激活多个设备中的数据</li><li>激活扩展跟踪器</li><li>管理相机功能：闪灯光和连续自动对焦</li></ol><p><strong>Cylinder Targets(圆柱跟踪)</strong><br>筒形靶样品显示了如何检测的圆筒形靶和围绕圆柱体的圆周运动3D对象。主要功能包括：</p><ol><li>检测气缸目标和跟踪</li><li>遮挡处理</li><li>激活扩展跟踪</li><li>管理相机功能：闪灯光和连续自动对焦</li></ol><p><strong>Multi Targets(多目标)</strong><br> 多目标的示例显示了如何检测一个简单的长方体形状的三维动画和周边形状的3D对象。主要功能包括：</p><ol><li>检测与长方体形状的3D跟踪</li><li>遮挡处理</li><li>激活扩展跟踪</li><li>管理相机功能：山灯光和连续自动对焦</li></ol><p><strong>User Defined Targets(用户自定义目标)</strong><br>用户定义的目标示例显示了如何捕获和从用户选择的摄像机的视频帧运行时创建一个图像的目标。包括主要功能：</p><ol><li>创建和管理用户的定义的图像目标</li><li>激活扩展跟踪</li><li>管理相机功能：闪灯光和连续自动对焦</li></ol><p><strong>Smart Terrain(智能地形)</strong><br> 智能地形示例应用程序演示了如何在一个目标让聪明的地形和使用重建网格渲染的内容。主要包括功能：</p><ol><li>从已知的目标初始化</li><li>扫描表面找对象</li><li>在主要绘制网格</li><li>上主表面中找到的对象的渲染的箱</li></ol><p><strong>Cloud Recognition(云识别)</strong><br> 云Reco的示例显示了如何使用云识别服务识别位于云数据库的目标。 主要功能包括：</p><ol><li>管理检测基于云的图像目标跟踪</li><li>激活扩展跟踪</li><li>管理相机功能：闪光灯和连续自动对焦</li></ol><p><strong>Text Recognition (文字识别)</strong><br> 文本识别样本显示在相机画面的指定区域内的动态识别英语单词。 主要功能包括</p><ol><li>检测的英语单词和跟踪包含在默认的文字列表</li><li>管理相机功能：闪光灯 </li></ol><p><strong>Frame Markers(帧标记)</strong><br> 帧标记示例演示如何检测帧标记，并呈现在上面一个简单的3D对象。 主要功能包括：</p><ol><li>检测和多帧标记追踪 </li><li>管理相机功能：闪光灯和连续自动对焦</li></ol><p><strong>Virtual Button(虚拟按键)</strong><br> 虚弥按钮示例显示了如何开发人员可以在触发时间触及或闭塞得摄像机视图时，图像的目标定义的矩形区域。样品呈现，当虚拟按钮中的一个被触发改变的颜色的3D对象。主要功能包括：</p><ol><li>按钮遮挡事件处理</li><li>多个虚拟按钮激活</li><li>管理相机功能：闪光灯和连续自动对焦</li></ol>]]></content>
      
      <categories>
          
          <category> vuforia </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuforia </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>androidstudiogit设置忽略</title>
      <link href="/2016/09/21/androidstudiogit%E8%AE%BE%E7%BD%AE%E5%BF%BD%E7%95%A5/"/>
      <content type="html"><![CDATA[<p>要忽略的文件<br>-.idea文件夹<br>-.gradle文件夹<br>-所有文的build文件夹<br>-所有的.iml文件<br>-loca.properties文件</p><p>所以：<br>跟目录的<br>.gitignore<br>.gradle<br>/local.properties<br>/.idea/workspace.xml<br>/.idea/libraries<br>.DS_Store<br>/build<br>/captures<br>.idea<br>*.iml</p><p>module目录下的.gitignore<br>/build<br>*.iml</p>]]></content>
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>androidstudiosvn设置忽略</title>
      <link href="/2016/09/21/androidstudiosvn%E8%AE%BE%E7%BD%AE%E5%BF%BD%E7%95%A5/"/>
      <content type="html"><![CDATA[<p>一、Android Studio创建的Android项目一般需要忽略<br>1、.idea文件夹<br>2、.gradle文件夹<br>3、所有的build文件夹<br>4、所有的.iml文件<br>5、local.properties文件。<br>方法一、在项目的.idea/workspace.xml的文件里设置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;    </span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">"ChangeListManager"</span>&gt;</span>    </span><br><span class="line">        ...    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ignored</span> <span class="attr">path</span>=<span class="string">".gradle/"</span> /&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">ignored</span> <span class="attr">path</span>=<span class="string">".idea/"</span> /&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">ignored</span> <span class="attr">path</span>=<span class="string">"gradle/"</span> /&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">ignored</span> <span class="attr">path</span>=<span class="string">"项目名/build/"</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ignored</span> <span class="attr">path</span>=<span class="string">"gradlew"</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ignored</span> <span class="attr">path</span>=<span class="string">"gradlew.bat"</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ignored</span> <span class="attr">mask</span>=<span class="string">"*.iml"</span> /&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">ignored</span> <span class="attr">path</span>=<span class="string">"local.properties"</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ignored</span> <span class="attr">path</span>=<span class="string">"build/"</span> /&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">ignored</span> <span class="attr">mask</span>=<span class="string">"*.apk"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">component</span>&gt;</span>    </span><br><span class="line">    ...    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><a href="http://a1.eoeandroid.com/attachment/forum/201607/18/172122qdxadmdcidnzabmb.png" target="_blank" rel="noopener"><img src="http://a1.eoeandroid.com/attachment/forum/201607/18/172122qdxadmdcidnzabmb.png" alt=""></a></p>]]></content>
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android之Lru算法</title>
      <link href="/2016/06/18/Android%E4%B9%8BLru%E7%AE%97%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>Lru：</p><p>   LRU是Least Recently Used 的缩写，翻译过来就是“最近最少使用”，LRU缓存就是使用这种原理实现，简单的说就是缓存一定量的数据，当超过设定的阈值时就把一些过期的数据删除掉，比如我们缓存10000条数据，当数据小于10000时可以随意添加，当超过10000时就需要把新的数据添加进来，同时要把过期数据删除，以确保我们最大缓存10000条，那怎么确定删除哪条过期数据呢，采用LRU算法实现的话就是将最老的数据删掉。</p><p> 1.）初始化MemoryCache</p><p>  这里内存缓存的是Drawable 而不是Bitmap 理由是Drawable相对Bitmap来说有很大的内存优势<br>  int maxMemory = (int) Runtime.getRuntime().maxMemory();//获取系统分配给应用的总内存大小<br>  int mCacheSize = maxMemory / 8;//设置图片内存缓存占用八分之一<br>  mMemoryCache = new LruCache<string, drawable="">(mCacheSize) {<br>  //必须重写此方法，来测量Bitmap的大小<br>  @Override<br>  protected int sizeOf(String key, Drawable value) {<br>  　　if (value instanceof BitmapDrawable) {<br>  　　　　Bitmap bitmap = ((BitmapDrawable) value).getBitmap();<br>  　　　　return bitmap == null ? 0 : bitmap.getByteCount();<br>　　　}<br>　　　return super.sizeOf(key, value);<br>            }<br>        };</string,></p><p>2.）添加一个Drawable到内存缓存<br>    /**</p><pre><code> * 添加Drawable到内存缓存 * * @param key * @param drawable */private void addDrawableToMemoryCache(String key, Drawable drawable) {    if (getDrawableFromMemCache(key) == null &amp;&amp; drawable != null) {        mMemoryCache.put(key, drawable);    }}</code></pre><p>3.）从内存缓存中获取一个Drawable</p><pre><code>/** * 从内存缓存中获取一个Drawable * * @param key * @return */public Drawable getDrawableFromMemCache(String key) {    return mMemoryCache.get(key);}</code></pre><p>4.）从内存缓存中移除一个Drawable</p><p>   /**</p><pre><code> * 从内存缓存中移除 * * @param key */public void removeCacheFromMemory(String key) {    mMemoryCache.remove(key);}</code></pre><p>5.）清空内存缓存</p><pre><code>/** * 清理内存缓存 */public void cleanMemoryCCache() {    mMemoryCache.evictAll();}</code></pre><p>其实Lru缓存机制本质上就是存储在一个LinkedHashMap存储，为了保障插入的数据顺序，方便清理。</p><p>基于DiskLruCache实现磁盘缓存：</p><p>   DiskLruCache类并不是谷歌官方实现，需要自行下载，下载地址：<a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">https://github.com/JakeWharton/DiskLruCache</a></p><p>  1.）初始化DiskLruCache</p><pre><code>File cacheDir = context.getCacheDir();//指定的是数据的缓存地址 long diskCacheSize = 1024 * 1024 * 30;//最多可以缓存多少字节的数据 int appVersion = DiskLruUtils.getAppVersion(context);//指定当前应用程序的版本号 int valueCount = 1;//指定同一个key可以对应多少个缓存文件 try {     mDiskCache = DiskLruCache.open(cacheDir, appVersion, valueCount, diskCacheSize); } catch (Exception ex) { }</code></pre><p>2.）写入一个文件到磁盘缓存</p><pre><code>/** * 添加Bitmap到磁盘缓存 * * @param key * @param value */private void addBitmapToDiskCache(String key, byte[] value) {    OutputStream out = null;    try {        DiskLruCache.Editor editor = mDiskCache.edit(key);        if (editor != null) {            out = editor.newOutputStream(0);            if (value != null &amp;&amp; value.length &gt; 0) {                out.write(value);                out.flush();                editor.commit();            } else {                editor.abort();            }        }        mDiskCache.flush();    } catch (IOException e) {        e.printStackTrace();    } finally {        DiskLruUtils.closeQuietly(out);    }}</code></pre><p>3.）从磁盘缓存中读取Drawable</p><pre><code>/** * 从磁盘缓存中获取一个Drawable * * @param key * @return */public Drawable getDrawableFromDiskCache(String key) {    try {        DiskLruCache.Snapshot snapShot = mDiskCache.get(key);        if (snapShot != null) {            InputStream is = snapShot.getInputStream(0);            Bitmap bitmap = BitmapFactory.decodeStream(is);            Drawable drawable = DiskLruUtils.bitmap2Drawable(bitmap);            //从磁盘中读取到之后 加入内存缓存            addDrawableToMemoryCache(key, drawable);            return drawable;        }    } catch (IOException e) {        e.printStackTrace();    }    return null;}</code></pre><p>4.）从磁盘缓存中移除</p><pre><code>/** * 从磁盘缓存中移除 * * @param key */public void removeCacheFromDisk(String key) {    try {        mDiskCache.remove(key);    } catch (Exception e) {    }}</code></pre><p>5.）清空磁盘缓存</p><pre><code>/** * 清理磁盘缓存 */public void cleanDiskCache() {    try {        mDiskCache.delete();    } catch (Exception e) {    }}</code></pre><p>图片下载过程：</p><p>   接下来实例中用到了一点RxJava的知识有不了解RxJava的请自行了解一下。</p><p>  1.）采用异步方式操作磁盘缓存和网络下载， 内存缓存可以在主线程中操作</p><p>   public void disPlay(final ImageView imageView, String imageUrl) {<br>        //生成唯一key<br>        final String key = DiskLruUtils.hashKeyForDisk(imageUrl);<br>        //先从内存中读取<br>        Drawable drawableFromMemCache = getDrawableFromMemCache(key);<br>        if (drawableFromMemCache != null) {<br>            imageView.setImageDrawable(drawableFromMemCache);<br>            return;<br>        }<br>        Observable.just(imageUrl)<br>                .map(new Func1<string, drawable="">() {<br>                    @Override<br>                    public Drawable call(String imageUrl) { // 参数类型 String<br>                        //从磁盘中读取<br>                        Drawable drawableFromDiskCache = getDrawableFromDiskCache(key);<br>                        if (drawableFromDiskCache != null) {<br>                            return drawableFromDiskCache;<br>                        }<br>                        //网络下载<br>                        return download(imageUrl); // 返回类型 Drawable<br>                    }<br>                })<br>                .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程<br>                .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程<br>                .subscribe(new Action1<drawable>() {<br>                    @Override<br>                    public void call(Drawable drawable) { // 参数类型 Drawable<br>                        imageView.setImageDrawable(drawable);<br>                    }<br>                });<br>    }</drawable></string,></p><p>2.）下载图片过程以及处理</p><p> private Drawable download(String imageUrl) {<br>        HttpURLConnection urlConnection = null;<br>        ByteArrayOutputStream bos = null;<br>        InputStream ins = null;<br>        try {<br>            final URL url = new URL(imageUrl);<br>            urlConnection = (HttpURLConnection) url.openConnection();<br>            ins = urlConnection.getInputStream();<br>            bos = new ByteArrayOutputStream();<br>            int b;<br>            while ((b = ins.read()) != -1) {<br>                bos.write(b);<br>            }<br>            bos.flush();<br>            byte[] bytes = bos.toByteArray();<br>            Bitmap bitmap = DiskLruUtils.bytes2Bitmap(bytes);<br>            String key = DiskLruUtils.hashKeyForDisk(imageUrl);<br>            Drawable drawable = DiskLruUtils.bitmap2Drawable(bitmap);<br>            //加入内存缓存<br>            addDrawableToMemoryCache(key, drawable);<br>            //加入磁盘缓存<br>            addBitmapToDiskCache(key, bytes);<br>            return drawable;<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        } finally {<br>            if (urlConnection != null) {<br>                urlConnection.disconnect();<br>            }<br>            DiskLruUtils.closeQuietly(bos);<br>            DiskLruUtils.closeQuietly(ins);<br>        }<br>        return null;<br>    }</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> glide </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android之Glide缓存</title>
      <link href="/2016/06/17/Android%E4%B9%8BGlide%E7%BC%93%E5%AD%98/"/>
      <content type="html"><![CDATA[<p><strong>GlideModule使用</strong>：<br>　　GlideModule 是一个抽象方法，全局改变 Glide 行为的一个方式，通过全局GlideModule 配置Glide，用GlideBuilder设置选项，用Glide注册ModelLoader等。</p><ol><li><p>自定义一个GlideModule<br>public class MyGlideModule implements GlideModule {<br>@Override public void applyOptions (Context context, GlideBuilder builder){</p><p>　　}<br>}<br>@Override public void registerComponents(Context context, Glide glide){</p><p>　　}<br>}</p></li><li><p>&lt; mainfest …&gt;<br>　　&lt; application …&gt;<br>　　 　　&lt; meta-date<br>　　　　　android:name=”com.mypackage.MyGlideModule”<br>　　　　　android:value=”GlideModule” /&gt;<br>　　　&lt; / application&gt;<br>　&lt; / manifest&gt;</p></li><li><p>添加混淆处理<br>　　-keepnames class com.mypackage.MyGlideModule<br>　　# or more generally:<br>　　#-keep public class * implements com.bumptech.glide.module.GlideModule</p></li><li><p>多个GlideModule冲突问题<br>　　GlideModule不能指定调用顺序，所以应该避免不同的GlideModule之间有冲突的选项设置，可以考虑将所有的设置都放到一个GlideModule里面，或者排除掉某个manifest文件的某个Module，代码如下：<br>&lt; meta-data android:name=”com.mypackage.MyGlideModule” tools:node=”remove” / &gt;</p></li></ol><p><strong>GlideBuilder设置选项：</strong></p><ol><li>设置Glide内存缓存大小<br>　　int maxMemory = (int)Runtime.getRuntime().maxMemory();//获取系统分配给应用的总内存大小<br>int memoryCacheSize = maxMemory / 8 ;//设置图片内存缓存占用八分之一<br>//设置缓存大小<br>builder.setMemoryCache(new LruResourceCache(memoryCacheSize));</li></ol><p>　获取默认的内存使用计算函数<br>　MemorySizeCalculator calculator = new MemorySizeCalcylator(context);<br>　int defauleMemoryCacheSize = calculator.getMemoryCacheSize();<br>　int defaultBitmapPoolSize = calculator.getBitmapPoolSize();　</p><ol><li><p>设置Glide磁盘缓存大小<br>　　File cacheDir = context.getExternalCacheDir();//指定的是数据缓存地址<br>　　int disCacheSize = 1024 <em> 1024 </em>30 ;//最多可以缓存多少字节的数据<br>　　//设置磁盘缓存大小<br>　　builder.setDiskCache(new DiskLruCacheFactory(cacheDir.getPath(),”glide”,diskCacheSize));<br>也可以通过如下两种方式<br>//存放在data/data/xxxx/cache/<br>builder.setDiskCache(new InternalCacheDiskCacheFactory(context, “glide”, diskCacheSize));<br>//存放在外置文件浏览器<br>builder.setDiskCache(new ExternalCacheDiskCacheFactory(context, “glide”, diskCacheSize));</p></li><li><p>设置图片解码格式<br>//设置图片解码格式<br>builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888);</p></li><li><p>设置缓存内存大小<br>//设置BitmapPool缓存内存大小<br>builder.setBitmapPool(new LruBitmapPool(memoryCacheSize));</p></li></ol><ol><li>设置一个用来检索cache中没有的Resource的ExecutorService<br>为了使缩略图请求正确工作，实现类必须把请求根据Priority优先级排好序。<br>builder.setDiskCacheService(ExecutorService service);<br>builder.setResizeService(ExecutorService service);</li></ol><p><strong>使用ModelLoader自定义数据源</strong>：<br>例如我们使用了七牛云存储，要根据不同的要求请求不同尺寸不同质量的图片，这时我们就可以使用自定义数据源</p><ol><li>定义处理URL接口</li></ol><p>public interface IDataModel {</p><p>　　String buildDataModelUrl (int width , int height );</p><p>}</p><ol><li><p>实现处理URL接口</p><p>public class JpgDataModel implements IDataModel {</p><p>　　private String dataModelUrl ;</p><p>　　public JpgDataModel (String dataModelUrl){<br>　　<br>　　 　　this.dataModelUrl = dataModelUrl;</p></li></ol><p>　　}</p><p>　　@Override<br>　　public String buildDataModelUrl(int width , int height ){</p><p> 　　 　　return String.format(<br>  　　 　　“%s?imageView2/1/w/%d/h/%d/format/jpg”,<br>  　　 　　dataModelUrl, width, height);<br> 　　 　　} 　　<br> 　　}    </p><p>  public class WebpDataModel implements IDataModel {</p><p> 　　private String dataModelUrl ;</p><p> 　　public WebpDataModel (String dataModelUrl){<br> 　　<br>  　　 　　this.dataModelUrl = dataModelUrl;</p><p>　　}</p><p>　　@Override<br>　　public String buildDataModelUrl(int width , int height ){</p><p> 　　 　　return String.format(<br>  　　 　　“%s?imageView2/1/w/%d/h/%d/format/webp”,<br>  　　 　　dataModelUrl, width, height);<br> 　　 　　} 　　<br> 　　}    </p><ol><li><p>实现ModelLoader</p><p>public class MyDataLoader extends BaseGlideUrlLoader<idatamodel> {<br> public MyDataLoader(Context context) {</idatamodel></p><p> 　super(context);</p><p>}</p><p>public MyDataLoader(ModelLoader<glideurl, inputstream=""> urlLoader) {</glideurl,></p><p>　super(urlLoader, null);</p><p>}</p><p>@Override<br>protected String getUrl(IDataModel model, int width, int height) {<br>　<br>　　return model.buildDataModelUrl(width, height);</p><p>}</p><p>/<em>* </em>/<br>public static class Factory implements ModelLoaderFactory<idatamodel, inputstream=""> {<br>　 @Override<br>　 public ModelLoader<idatamodel, inputstream=""> build(Context context, GenericLoaderFactory factories) {<br>　　<br>　　return new MyDataLoader(factories.buildModelLoader(GlideUrl.class, InputStream.class));<br>　<br>　　　}<br>　　@Override<br>　　public void teardown() {<br>　　}<br>　}<br>}</idatamodel,></idatamodel,></p></li><li><p>根据不同的要求采用不同的策略加载图片</p><p>　　//加载jpg图片<br>　　Glide.with(this).using(new MyDataLoader(this)).load(new JpgDataModel(imageUrl)).into(imageView);<br>　　//加载webp图片<br>　　Glide.with(this).using(new MyDataLoader(this)).load(new WebpDataModel(imageUrl)).into(imageView);</p></li><li><p>如何跳过.using()</p></li></ol><p>　public class MyGlideModule implements GlideModule {<br>　　<br>　　　@Override<br>　　　public void registerComponents(Context context, Glide glide) {<br>　　　　glide.register(IDataModel.class, InputStream.class, new MyUrlLoader.Factory());<br>　<br>　　}<br>　}</p><p>　　上面的实现跳过using()</p><p>　　//加载jpg图片<br>　　Glide.with(this).load(new JpgDataModel(imageUrl)).into(imageView);<br>　　//加载webp图片<br>　　Glide.with(this).load(new WebpDataModel(imageUrl)).into(imageView);</p><p>　　使用signature()实现自定义cacheKey：<br>　　Glide 以 url、viewwidth、viewheight、屏幕的分辨率等做为联合key，官方api中没有提供删除图片缓存的函数，官方提供了signature()方法，将一个附加的数据加入到缓存key当中，多媒体存储数据，可用MediaStoreSignature类作为标识符，会将文件的修改时间、mimeType等信息作为cacheKey的一部分，通过改变key来实现图片失效相当于软删除。</p><p>　1.使用StringSignature</p><p>　Glide.with(this).load(yourFileDataModel).signature(new StringSignature(“1.0.0”)).into(imageView);</p><p>　2.使用MediaStoreSignature </p><p>　Glide.with(this) .load(mediaStoreUri).signature(new MediaStoreSignature(mimeType, dateModified, orientation)).into(view);</p><p>　3.使用自定义Signature</p><p>　public class IntegerVersionSignature implements Key {<br>    　　　private int currentVersion;<br>    　　　public IntegerVersionSignature(int currentVersion) {<br>    　　　　　this.currentVersion = currentVersion;<br>　　}<br>　@Override<br>　public boolean equals(Object o) {<br>　　　if (o instanceof IntegerVersionSignature) {<br>　　　　IntegerVersionSignature other = (IntegerVersionSignature) o;<br>　　　　return currentVersion = other.currentVersion;<br>　　　}<br>　　　return false;<br>　}<br>  @Override<br>  public int hashCode() {<br>  　return currentVersion;<br>　}<br>　@Override<br>　public void updateDiskCacheKey(MessageDigest md) {<br>　<br>　　messageDigest.update(ByteBuffer.allocate(Integer.SIZE)<br>.putInt(signature).array());</p><p>　}<br>}</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> glide </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android之初识Glide</title>
      <link href="/2016/06/16/Android%E4%B9%8B%E5%88%9D%E8%AF%86Glide/"/>
      <content type="html"><![CDATA[<p><strong>Glide简介：</strong><br>　　　　　Glide 是 Google 员工的开源项目， Google I/O 上被推荐使用，一个高效、开源、Android设备上的媒体管理框架，它遵循BSD、MIT以及Apache 2.0协议发布。Glide具有获取、解码和展示视频剧照、图片、动画等功能，它还有灵活的API，这些API使开发者能够将Glide应用在几乎任何网络协议栈里。创建Glide的主要目的有两个，一个是实现平滑的图片列表滚动效果，另一个是支持远程图片的获取、大小调整和展示。</p><p>gitHub地址：<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">https://github.com/bumptech/glide</a></p><p><strong>Glide特点</strong></p><ul><li>使用简单</li><li>可配置度高，自适应程度高</li><li>支持常见图片格式Jpg png gif webp</li><li>支持多种数据源网络、本地、资源、Assets 等</li><li>高效缓存策略支持Memory和Disk图片缓存</li><li>默认Bitmap格式采用RGB_565内存使用至少减少一半</li><li>生命周期集成根据Activity/Fragment生命周期自动管理请求</li><li>高效处理Bitmap使用Bitmap     Pool使Bitmap复用，主动调用recycle回收需要回收的Bitmap，减小系统回收压力</li></ul><p><strong>Glide简单使用</strong></p><ol><li><p>添加引用 build.gradle 中添加配置</p><p> compile ‘com.github.bumptech.glide:glide:3.7.0’</p></li><li><p>设置绑定生命周期<br>我们可以更加高效的使用Glide提供的方式进行绑定，这样可以更好的让加载图片的请求的生命周期动态管理起来</p><p> Glide.with(Context context);// 绑定Context<br> Glide.with(Activity activity);// 绑定Activity<br> Glide.with(FragmentActivity activity);// 绑定FragmentActivity<br> Glide.with(Fragment fragment);// 绑定Fragment</p></li><li><p>简单的加载图片实例</p><p>Glide.with(this).load(imageUrl).into(imageView);</p></li><li><p>设置加载中以及加载失败图片<br>api里面对placeholder()、error()函数中有多态实现 用的时候可以具体的熟悉一下</p><p>Glide.with(this).load(imageUrl).placeholder(R.mipmap.ic_launcher).error(R.mipmap.ic_launcher).into(imageView);</p></li><li><p>设置跳过内存缓存</p><p>Glide.with(this).load(imageUrl).into(imageView);</p></li><li><p>设置下载优先级</p><p>Glide.with(this).load(imageUrl).priority(Priority.NORMAL).into(imageView);</p></li><li><p>设置缓存策略</p><p>Glide.with(this).load(imageUrl).diskCacheStrategy(DiskCacheStrategy.ALL).into(imageView);</p><p>策略解说：<br>all:缓存源资源和转换后的资源<br>none:不作任何磁盘缓存<br>source:缓存源资源<br>result：缓存转换后的资源</p></li><li><p>设置加载动画<br>api也提供了几个常用的动画：比如crossFade()</p><p>Glide.with(this).load(imageUrl).animate(R.anim.item_alpha_in).into(imageView);</p><p>R.anim.item_alpha_in</p><p>  &lt; ? xml version=”1.0” encoding=”utf-8”?&gt;<br>  &lt; set xmlns:android=”<a href="http://schemas.android.com/apk/res/android&quot;&gt;" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android&quot;&gt;</a><br>  　　&lt; alpha<br>  　　　　　android:duration=”500”<br>  　　　　　android:fromAlpha=”0.0”<br>  　　　　　android:toAlpha=”1.0”/&gt;<br>  &lt;/ set&gt;</p></li><li><p>设置缩略图支持<br>这样会先加载缩略图 然后在加载全图</p><p>Glide.with(this).load(imageUrl).thumbnail(0.1f).into(imageView);</p></li><li><p>设置加载尺寸</p><p>Glide.with(this).load(imageUrl).override(800, 800).into(imageView);</p></li><li><p>设置动态转换</p><p>Glide.with(this).load(imageUrl).centerCrop().into(imageView);</p><p>api提供了比如：centerCrop()、fitCenter()等函数也可以通过自定义Transformation，举例说明：比如一个人圆角转化器</p><p>public class GlideRoundTransform extends BitmapTransformation{<br>private float radius = 0f;<br>public GlideRoundTransform(Context context) {<br>　　this(context, 4);</p><p>}<br>public GlideRoundTransform(Context context, int dp) {<br>　　super(context);<br>　　this.radius = Resources.getSystem().getDisplayMetrics().density * dp;</p><p>}<br>@Override<br>protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {<br>　　return roundCrop(pool, toTransform);<br>}<br>private Bitmap roundCrop(BitmapPool pool, Bitmap source) {<br>　　if (source == null) return null;</p><p>　　   　　Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</p><p>　　if (result == null) {   　　</p><p> 　　   　　result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</p><p>　　}</p><p>　　Canvas canvas = new Canvas(result);<br>　　Paint paint = new Paint();<br>　　paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));<br>　　paint.setAntiAlias(true);<br>　　RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight());<br>　　return result;</p><p>}</p><p>@Override<br>public String getId() {</p><p>   return getClass().getName() + Math.round(radius);</p><p>  　　}<br>}</p><p>Glide.with(this).load(imageUrl).transform(new GlideRoundTransform(this)).into(imageView);</p></li><li><p>设置要加载的内容</p><p>项目中有很多需要先下载图片然后再做一些合成的功能，比如项目中出现的图文混排，该如何实现目标下</p><p>Glide.with(this).load(imageUrl).centerCrop().into(new SimpleTarget<glidedrawable>() {<br>   　　@Override<br>   　　public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; glideAnimation) {</glidedrawable></p><p>　　imageView.setImageDrawable(resource);   　　</p><p>　　}   　　<br>});<br>Glide.with(this).load(imageUrl).transform(new GlideRoundTransform(this)).into(imageView);</p></li><li><p>设置监听请求接口</p><p>Glide.with(this).load(imageUrl).listener(new RequestListener<string, glidedrawable="">() {<br>  　　@Override<br>  　　public boolean onException(Exception e, String model, Target<glidedrawable> target, boolean isFirstResource) {<br>  　　   　　return false;<br>　　}<br>　　@Override<br>　　public boolean onResourceReady(GlideDrawable resource, String model, Target<glidedrawable> target, boolean isFromMemoryCache, boolean isFirstResource) {</glidedrawable></glidedrawable></string,></p><p> 　　//imageView.setImageDrawable(resource);</p><p>　　 return false;</p><p>　　}}).into(imageView);</p></li></ol><p>设置监听的用处 可以用于监控请求发生错误来源，以及图片来源 是内存还是磁盘</p><p> 14.设置动态GIF加载方式</p><p>　　Glide.with(this).load(imageUrl).asBitmap().into(imageView);//显示gif静态图片<br>　　Glide.with(this).load(imageUrl).asGif().into(imageView);//显示gif动态图片</p><p> 15.缓存的动态清理</p><p>　　Glide.get(this).clearDiskCache();//清理磁盘缓存 需要在子线程中执行<br>　　Glide.get(this).clearMemory();//清理内存缓存  可以在UI主线程中进行</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> glide </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前段UI框架</title>
      <link href="/2016/06/08/%E5%89%8D%E6%AE%B5Ui%E6%A1%86%E6%9E%B6/"/>
      <content type="html"><![CDATA[<h1 id="十个前段UI优秀框架"><a href="#十个前段UI优秀框架" class="headerlink" title="十个前段UI优秀框架"></a>十个前段UI优秀框架</h1><p>Bootstrap</p><p>首先说 Bootstrap，估计你也猜到会先说或者一定会有这个( 呵呵了 )，这是说明它的强大之处，拥有框架一壁江山的势气。自己刚入道的时候本着代码任何一个字母都得自己敲出来挡我者废的决心，来让自己成长。结果受到周围各种基友的引诱开始了 Bootstrap 旅程。本人虽然是个设计+前端的万里有一的人才，但是老天只让我会用 PS 和各种设计工具却不给我跟设计妹子一样的审美，所以这也是我最初选择 Bootstrap 的原因之一，它让我做出来的东西好歹能在妹子面前装个逼，不过时间长了难免觉得 Bootstrap 美的让人烦躁， 但好在它的每个版本都会有很大的改变，不会让人觉得自己做的网站会跟很多网站撞脸。Bootstrap 的用法及其简单( 这也可能就是 Bootstrap 作者阅攻城士无数，了解他们痛的结果 )，以至于是个小前端都可以快速上手，几乎没什么学习成本。</p><p>官网：<a href="http://getbootstrap.com/" target="_blank" rel="noopener">http://getbootstrap.com/</a></p><p>Github：<a href="https://github.com/twbs/bootstrap/" target="_blank" rel="noopener">https://github.com/twbs/bootstrap/</a></p><p>作者：Mark Otto 和Jacob Thornton Star：118,264</p><p>总结：Bootstrap 最大的优势就是它非常流行，流行就代表你有问题就有很多人帮你解决问题，就代表装逼它就是利器，还有就是界面比较和谐，容易上手，关注它的童鞋应该发现最新 V4 版也开始支持 FlexBox 布局，这是非常好的升级体验。 劣势是 class 命名不够语义化，并且各种缩写，以至于我离了文档就是个菜，最近开始整混合 APP，选框架的时候首选就是它，但之前搞 PC 一直没注意，后来搞混合右键属性看它的时候，瞬间一阵凉风袭来，Bootstrap 好小，小到我只好选择别的框架。<br><a id="more"></a><br>AUI</p><p>第三个是最近刚起来的AUI，虽然作者声称是专为APICloud开发者设计的一套UI框架，但实际它还是解决了很多移动前端开发的普遍问题，是主要面向混合开发的 CSS 框架。看起来作者比较猖狂，各种高级 CSS3 遍地使用，这让我也不得不去查查这些个 CSS3 的兼容性。不负众望果然选的都是兼容不错的属性，哈哈了一顿激动从前辈手上大胆认识了几个好东西，并且框架还提供了聊天界面、计数列表等组件，解决了很多复杂的让我骂娘的布局，现在可以直接拿走就用。</p><p>Github：<a href="https://github.com/liulangnan/aui" target="_blank" rel="noopener">https://github.com/liulangnan/aui</a></p><p>官网：<a href="http://www.auicss.com/" target="_blank" rel="noopener">http://www.auicss.com/</a></p><p>作者：流浪男 Star：682</p><p>总结：这个框架对我来说有个优点就是纯 CSS 框架，自己以前也就用过 Pure，自己有点 JS 能力，如果不是复杂的效果，找个纯 CSS 框架自己随便改改就可以，而现在 CSS3 也已经能够做到动画，效率、质量、高效全兼顾，所以还是选择了这种 CSS 框架。有一点觉得不满的是这框架的文档真的好那什么，说好的高大上呢。</p><p>Amaze UI</p><p>第二个介绍的是妹子UI，最初使用它是因为本尊遇到了一个爱纠结细节设计士，有一次她跟我的字体较上真了，结果一句顶万句的 BOOS 夸了她，我只好根据她的想法去解决，结果最后找到了Amaze UI 框架( 我不介意你叫我懒淫 )，按照官方的话说就是 “基于社区开源项目构建的一个跨屏前端框架，以移动优先，从小屏到大屏，最终实现所有屏幕适配，适应移动互联潮流” 。但其实我就是看中它能解决国内浏览器存在的跨屏适配和兼容性问题。</p><p>官网：<a href="http://amazeui.org/" target="_blank" rel="noopener">http://amazeui.org/</a></p><p>Github：<a href="https://github.com/amazeui/amazeui" target="_blank" rel="noopener">https://github.com/amazeui/amazeui</a></p><p>所属公司：云适配 Star：10,817</p><p>总结：Amaze UI 总的来说就是加入更多符合中国市场特性的元素，框架对跨屏、适配都做了的比较好的处理并且准备一了一系列的常用的网页组件，为减少搞兼容、适配各种敲键盘的加班狗们的工作时间做了不小的贡献。，框架还对中文排版优化，兼容中国本土主流浏览器、轻量化，不仅适用于桌面端，还更更适合移动端、包含一些封装好的Widgets。不过自也就我感觉 Amaze UI 文档是否有点太那什么了，比如 “人们不会在乎jQuery的那点流量。”，说实的在这真没啥，不过我从来不会说出来( 哈哈 )，代码和设计上感觉没太多突出的点。</p><p>Frozen UI</p><p>有段时间看到 QQ 瞬间高大上了，后来四处打听，原来 QQ 客服端也用了 混合开发，其中QQ会员前端用的是 Frozen UI，并且这套框架开源，欣喜若狂耐不住心里的寂寞直接上手试了一遍，初体验感觉基础样式效果简单色调清爽，有个比较活跃的社区所以组件什么的也比较丰富。</p><p>Github：<a href="https://github.com/frozenui/frozenui" target="_blank" rel="noopener">https://github.com/frozenui/frozenui</a></p><p>官网：<a href="http://frozenui.github.io/" target="_blank" rel="noopener">http://frozenui.github.io/</a></p><p>作者： QQVIP FD Team Star：2,307</p><p>总结：如果拿 Frozen UI 配合一些如 APICloud 用来做混合 APP 感觉就太酷了，或者原生的火鸡们拿去嵌套在应用中做前端开发，这个框架对 android 2.3 +、ios 4.0 + 做了兼容，或者拿来做 Web App 也是极好的选择，劣势的话从 UI 层面就可以看到了，谁让它是出生在QQ会员前端的呢。</p><p>Frozen UI</p><p>第三个是Frozen UI，有段时间看到 QQ 瞬间高大上了，后来四处打听，原来 QQ 客服端也用了 HTML 混合开发，其中QQ会员前端就是用的 Frozen UI，并且这套框架开源，欣喜若狂耐不住心里的寂寞直接上手三下五除二试了一遍就开始试用，初体验的就是基础样式效果简单色调清爽，有个比较活跃的社区所以组件什么的也比较丰富。</p><p>Github：<a href="https://github.com/frozenui/frozenui" target="_blank" rel="noopener">https://github.com/frozenui/frozenui</a></p><p>官网：<a href="http://frozenui.github.io/" target="_blank" rel="noopener">http://frozenui.github.io/</a></p><p>作者： QQVIP FD Team Star：1,067</p><p>总结：如果拿 Frozen UI 配合一些如 APICloud 用来做混合 APP 感觉就太酷了，或者原生的火鸡们拿去嵌套在应用中做前端开发，并且这个框架对 android 2.3 +、ios 4.0 + 做了兼容，或者拿来做 Web app 也是极好的选择，不过要是放在微信里比这更合适的 WeUI 框架更是首选了，劣势的话从 UI 层面就可以看到了，谁让它是出生在QQ会员前端的呢。</p><p>WeUIi</p><p>第四个是WeUI和同 FrozenUI都属于 差不多的 WeUi了，也是一个比较专一的框架，WeUI应该说比FrozenUI前者更专一，话说连个官网都不搞，所有答疑都在 gitHub Issues 解决了，这个框架极其简单，体积当然就不用说了，模块也就 7 个左右，不过体量虽然小做的却不错，口碑看 star 就够了，框架从 16/1/23 发版至今 github star 超过 7K,不过也不排除用户没地方发泄所以都跑到 git 上来，哈哈。</p><p>Github：<a href="https://github.com/weui/weui" target="_blank" rel="noopener">https://github.com/weui/weui</a></p><p>DEMO：<a href="http://weui.github.io/weui/" target="_blank" rel="noopener">http://weui.github.io/weui/</a></p><p>Star：16,573</p><p>总结：看完微信设计团队设计的这套 DEMO，二话不说如果要做微信公众，这个二话不说必然是首选了。框架不好的地方简而言之就是框架本身应该就没考虑过让用户用到非微信的场景之下。</p><p>SUI</p><p>“SUI 是一套基于bootstrap开发的前端组件库，同时它她也是一套设计规范。通过SUI，可以非常方便的设计和实现精美的页面”。 果然还是直接引用官方给的枯燥无味广告要节省自己的脑细胞( 囧… )，当然了就像广告说的，如果你之前用过 Bootstrap， 那么可以轻松转向 SUI，这可能就是淘宝给前端屌丝们的福利了。。 </p><p>Github：<a href="https://github.com/sdc-alibaba/sui" target="_blank" rel="noopener">https://github.com/sdc-alibaba/sui</a></p><p>官网：<a href="http://sui.taobao.org/sui/docs/index.html" target="_blank" rel="noopener">http://sui.taobao.org/sui/docs/index.html</a></p><p>Star：120</p><p>AUI</p><p>第六个是最近刚起来的最近刚起来的 AUI，虽然作者声称是专为APICloud开发者设计的一套UI框架，但实际它还是解决了很多移动前端开发的普遍问题，是它主要面向混合开发的 CSS 框架。，所以看起来作者比较猖狂，各种高级 CSS3 遍地使用，这也使得我不得不去查查这些个 CSS3 的兼容性。不负众望果然选的都是兼容不错的属性，哈哈了一顿激动从前辈手上大胆认识了几个好东西，并且框架还提供了聊天界面、计数列表等组件，解决了很多复杂的让我骂娘的布局，现在可以直接拿走就用。</p><p>Github：<a href="https://github.com/liulangnan/aui" target="_blank" rel="noopener">https://github.com/liulangnan/aui</a></p><p>官网：<a href="http://www.auicss.com/" target="_blank" rel="noopener">http://www.auicss.com/</a></p><p>作者：流浪男 Star：319</p><p>总结：这个框架对我来说有个优点就是纯 CSS 框架，自己以前也就用过 Pure，自己有点 js 能力，如果不是复杂的效果自己找个纯 CSS 框架自己随便改改就能达到效果，而现在 CSS3 也已经能够做到各种动画，效率、质量、高效各种一顿考虑所以还是选择了这种 CSS 框架。而一直觉得不满的是这框架的文档真的好那什么，说好的高大上呢。</p><p>MUI</p><p>曾经一直使用 Android 系统的我，后来见到 IOS，果断移情别恋了，不知道为什么苹果每次调整系统我都特别喜欢，后来一段时间因为缺设计我专门模仿 IOS 系统做 UI，但始终不能够做到很好，无意间就发现了 MUI 这个框架，这个框架给我的吸引之处就是它的 UI 是以 IOS 为主体设计的，当然它也补充了android特有UI样式。并且MUI官方声称用来开发深入以后发现拿它做 APP 还能够提高用户使用流畅度，然后便试着更深入的了解和使用一段时间。</p><p>官网：<a href="http://dev.dcloud.net.cn/mui/" target="_blank" rel="noopener">http://dev.dcloud.net.cn/mui/</a></p><p>Github：<a href="https://github.com/dcloudio/mui" target="_blank" rel="noopener">https://github.com/dcloudio/mui</a></p><p>Star：7,580</p><p>总结：就像之前说的这个框架是以两大系统为参照来封装UI组件，框架自身还有一个较为活跃的社区，不太好的地方这也是我特别关注的一点，关于开发应用的流畅度，我当然知道这是 H5 目前的劣势，但是看到官网给的描述，还是抱着期待的心理试试看能否提升，然而它其实还是需要是借助 Webview来提升，而不是框架本身。</p><p>Semantic UI</p><p>倒数第三个是 Semantic UI，接触这个框架还是因为 Bootstrap，Semantic UI 刚上线 github 就受到大量开发者的关注，以至于很多人拿它俩对比各种挑刺各种夸，是好是坏不能单凭别人三句四句就抬起手指开始赞，用了以后感觉 UI 上跟 Bootstrap 没太多的区别，不过代码命名规范上却相差甚大，本人认为 Semantic UI 是不是就想做的不一样，它的命名全是采用复合的方式，类名特别的离散，用的时候你得很小心自己扩展或者新增的 class 命名与它的类名冲突。</p><p>官网：<a href="http://www.semantic-ui.cn/" target="_blank" rel="noopener">http://www.semantic-ui.cn/</a></p><p>Github：<a href="https://github.com/semantic-org/semantic-ui/" target="_blank" rel="noopener">https://github.com/semantic-org/semantic-ui/</a></p><p>Star：38,191</p><p> Foundation</p><p>Foundation 算是框架界的元老啦，都说框架去的早，而这个框架一直到现在依然这么的热门，如果你比较介意 Bootstrap 开发撞脸的尴尬事情，那么你可以考虑使用 Foundation 。即使你使用预定义的 UI 元素, 也不会与其他网站太像，就像官方说的给开发者更灵活的框架体验。</p><p>官网：<a href="http://foundation.zurb.com/" target="_blank" rel="noopener">http://foundation.zurb.com/</a></p><p>Github：<a href="https://github.com/zurb/foundation-sites" target="_blank" rel="noopener">https://github.com/zurb/foundation-sites</a></p><p>Star：26,659</p><p>UiKit</p><p>UIkit是YOOtheme团队开发的，在许多WordPress主题中都有应用(也就是如果你是个 WordPress 爱好者，那么这个框架应该比较适合深究)，并且框架能够通过GUI编辑器和手动编辑，所以它提供了一个灵活、强大的自定义机制。框架借助LESS、jQuery、normalize.css及FontAwesome开源项目的独有特点，整合成了这么一款轻量级、模块化的前端框架。</p><p>官网：<a href="http://www.getuikit.com/" target="_blank" rel="noopener">http://www.getuikit.com/</a><br>Github：<a href="https://github.com/uikit/uikit" target="_blank" rel="noopener">https://github.com/uikit/uikit</a><br>作者：YOOtheme Star：11,037</p><p>Pure</p><p>终于最后一个了，我和你一样好开森 (～￣▽￣)～)，这个框架是我在做管理系统时接触的，选择使用也是因为框架小巧，并且是纯 CSS，没有太多的牵扯，好用来与其他框架快速结合使用。</p><p>官网：<a href="http://purecss.io/" target="_blank" rel="noopener">http://purecss.io/</a></p><p>Github：<a href="https://github.com/yahoo/pure/" target="_blank" rel="noopener">https://github.com/yahoo/pure/</a></p><p>Star：17,196</p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>androidstudio项目目录结构解析</title>
      <link href="/2016/04/10/androidstudio%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
      <content type="html"><![CDATA[<p>首先先上图<br><img src="http://ww1.sinaimg.cn/mw690/005zrb37gw1f9mtxo22gnj30bj0kngo7.jpg" alt="此处输入图片的描述"></p><p>大家看到的是android studio 创建的项目清单【图方便，就用完整的项目来做示例 - - 】<br>app/build app模块build编译输出的目录( 关于上传svn或github需要忽略的文件待会说明)<br>app/build.gradle (主要配置 编译sdk版本、编译工具    、包名、sdk最低支持版本、目标sdk版本、app版本号、app版本名称、ndk等等)<br>app/app.iml app模块的配置文件(Intellij模块文件，很重要但是基本不用管，大家都知道Intellij是AndroidStudio的亲妈的嘛，所以有这个文件是正常的)<br>app/proguard-rules.pro app模块proguard文件(混淆配置文件,主要用于打包签名apk配置混淆代码[是否混淆是可选的])<br>build.gradle 项目的build.gradle编译文件，主要就是申明仓库地址和版本号<br>settings.gradle定义项目包含哪些模块[指引用了哪些外库]<br>local.properties 配置SDK/NDK<br>nearby.iml 项目的配置文件<br>External Libraries 项目依赖的Lib, 编译时自动下载的</p><blockquote><p>AndroidStudio自动忽略</p></blockquote><pre><code>现在的AndroidStudio已经很智能了，当创建项目的时候自动给我们创建了一个上传svn或git需要忽略的文件如下：.gitignore 并给我们忽略了一些文件*.iml.gradle/local.properties/.idea/workspace.xml/.idea/libraries.DS_Store/build/captures手动忽略1、.idea文件2、.gradle文件夹3、所有的build文件夹4、所有的.iml文件5、local.properties文件</code></pre>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一秒钟看懂SaaS、CRM、OA、ERP、HR、进销存</title>
      <link href="/2016/03/28/%E4%B8%80%E7%A7%92%E9%92%9F%E7%9C%8B%E6%87%82SaaS%E3%80%81CRM%E3%80%81OA%E3%80%81ERP%E3%80%81HR%E3%80%81%E8%BF%9B%E9%94%80%E5%AD%98/"/>
      <content type="html"><![CDATA[<p> 　自2014年以来，SaaS、CRM、OA、ERP、HR、APM、进销存、财务系统等，这些名词大量出现在微信朋友圈、电视楼宇广告和千百万融资资讯中。它们到底是什么意思？相互之间又有什么区别？在这个飞速发展的互联网时代，再不知道这些可就OUT了！</p><p>　　SaaS、CRM、OA、ERP、HR、进销存究竟是什么？<br>　　<img src="http://img.mp.itc.cn/upload/20160409/7daac8961ba14a06af4f77edb2889702_th.jpg?_=5776061" alt="此处输入图片的描述"><br>SaaS模式就像用自来水</p><p>　　2015年被媒体和IT从业人员称为SaaS元年。什么是SaaS呢？SaaS是Software-as-a-Service（软件即服务）的简称，“软件即服务”，简单理解也就是“按需租用别人提供的软件服务”，它是一种软件交付模式。SaaS这个说法是区别于以往软件购买和交付方式而提出的。</p><p>　　在以往，如果你的公司需要使用一款软件来管理财务记账，作为公司管理者，你需要向软件提供公司说明需求、支付购买软件的费用并提供安装软件的硬件环境，然后软件公司就会上门安装调试软件，调试完后就可以正式投入使用了。</p><p>　　这里有一个很显著的特点是，软件都安装在你指定的地方，你拥有100%的管控权，相应的，你后续还需要继续投入人员和资源来维护系统的正常运行。</p><p>　　SaaS的模式就不一样了，在客户还没有到来之前，软件提供公司就自己提服务器、数据库等硬件，把软件安装发布好，这样作为软件使用方的你就变得轻松很多，一上来就可以直接进行体验，体验之后，你觉得哪些功能合适你的，就挑选出来，按月支付比较低廉的费用就可以正式使用了。后续的升级、维护也由软件公司负责。简而言之，SaaS模式就是软件提供公司事先把所有的软件相关工作都归类准备好了，用户直接过来挑选自己需要的用就OK了。</p><p>　　业内有一个很恰当的比喻：一开始的时候，各家都是自己挖井抽水蓄水，挖井抽水蓄水的技术是有专业的公司提供，但总的来说喝水这个事情是自家管自家的，这是传统软件的供水模式。在SaaS模式下，挖井抽水蓄水净水修水管这些工作对使用方来说都是透明的，你有需要的时候就打开水龙头取水就OK了，然后每月自来水公司会过来跟你结算。同样的，优缺点很明显，优点是按需用水省事了，成本变低了，缺点是水由水务公司完全控制，供水稳定性、供水质量取决于水务公司实力。</p><p>　　CRM是什么呢？追踪客户的</p><p>　　CRM是英文Customer Relationship Management （客户关系管理）的简称。这个比较好理解，就是用来管理客户的。</p><p>　　一般来说，CRM客户管理系统由客户信息管理、销售过程自动化（SFA）、营销自动化（MA）、客户服务与支持（CSS）管理、客户分析（CA）系统这5大主要功能模块组成。</p><p>　　通俗一点说，CRM系统特别是移动CRM系统能帮助你及你的同事很方便地记录客户信息、跟踪分析新老客户、挖掘潜在客户。</p><p>　　OA是什么呢？管办公室活动的</p><p>　　OA是Office Automation（办公自动化）的简称，本来OA涵盖的范围非常广泛，基本上所有和办公相关的系统都可以称作是OA，但现在大都数公司都把OA系统定义为企业内部的协作沟通系统，一般提供的功能有流程审批（请假报销等）、即时沟通、文档管理、内部论坛、任务管理、会议管理、通讯录、问卷调查等。</p><p>　　ERP是什么呢？生产制造一条龙全包</p><p>　　ERP是Enterprise Resource Planning（企业资源计划）的简称，从字面上理解，各企业的资源、计划相关的管理都可以算在ERP的范畴里，比如员工、生产、制造、财务、销售、采购、仓储、分销、质量等等，只要是用于企业管理的软件都属于ERP的范畴。由于越来越多的细分系统的出现，行业内人们为了做区分，一般把功能比较全面（往往包含从原料到生产到仓储到销售一系列）的偏生产制造的管理系统才定义为ERP系统，而其中某项细分功能的系统虽然原则上属于ERP，但一般不称为ERP。</p><p>　　HR软件是什么？管员工的</p><p>　　HR软件是human resource software（人力资源软件）的简称，就是用来管理人事相关的系统，比如招聘管理、职工管理、劳动合同、奖惩管理、办公用品、培训管理、绩效管理、考勤管理、社保管理等。</p><p>　　什么是进销存？</p><p>　　进销存是指企业管理过程中采购（进货）→入库（库存）→销售（销货）的三个管理过程。这三个过程是一般企业特别是中小商户的核心经营过程，用来管理这三个过程的系统就是进销存系统，简称进销存。</p><p>　　什么是财务系统？</p><p>　　财务系统是指专门用于完成会计工作的管理系统。财务系统一般包含：总账管理、固定资产管理、资金管理、客户及应收应付管理、报表管理、财务分析、核算系统等。</p><p>　　SaaS、CRM、OA、ERP、HR、进销存、财务系统的区别在哪里？</p><p>　　SaaS是一种软件交付（交易）模式，以这种“按需租用”模式提供服务的软件称为SaaS，目前大部分的软件都采取这种模式，也就是说大部分的OA、ERP、HR、进销存、财务系统都可以叫作SaaS软件。由于ERP系统覆盖的链条很长，一般需要深度定制，所以比较少是以SaaS提供的。</p><p>　　现在的CRM、OA、HR、进销存、财务系统一般都以SaaS方式提供，CRM更专注于销售方面的管理，OA更专注于企业内部的协作沟通，HR更专注于人力管理，进销存专注于仓库相关的管理、财务系统专注资产、预算相关的管理。</p><p>　　由于它们涉及到企业不同时间段、不同角色、不同业务等各个方面，同时也因为各企业的规模、经营方式几乎完全不同，所以目前没有哪一款产品能囊括CRM、OA、HR、进销存等这些功能，目前市面上的产品能还处于在自己专注的领域深耕发展的阶段。</p><p>　　当然为了更快地拉开同竞争对手的差距，它们往往选择开放相互对接的方式，比较钉钉这些OA系统就提供了开放平台，用于对接进销存、财务系统。</p><p>　　CRM、OA、ERP、HR、进销存、财务系统目前有哪些代表产品？</p><p>　　CRM的标杆是美国的Salesforce，国内有纷享逍客、销售易、红圈营销、八百客等。</p><p>　　OA在国内有钉钉、云之家、今目标、微信企业号、企业微信（即将上线）这几个产品，有很多稍微大一点的企业内部会自建OA系统，等内部使用实施成熟后也会开放出来供外部使用。</p><p>　　ERP和财务系统，素来有“南金蝶北用友”之称，这两家拿下中国大部分市场份额，SAP则是全球最成功是ERP厂商，据称85%的世界500强公司都有使用SAP系统，但这套系统非常昂贵非常复杂，不适用于中小企业。</p><p>　　HR。有北森、dayHR、金柚等，由于单纯的HR系统很容易被OA或进销存击穿，现在的HR往往做得非常深，人才评测、招聘等都会涉及。</p><p>　　进销存系统，有管家婆、智慧记、云销城、秦丝生意通等，在采购、销售、库存这三个最核心的管理环节需求会非常强烈，但对于操作速度要求很高，一般软件很难满足，所以目前来说进销存的普及率还不到8%。</p><p>　　2016年CRM、OA、ERP、HR、进销存、财务系统的趋势是怎么样的？</p><p>　　1、SaaS化。对于提供方而言标准化的SaaS产品更具有爆发性，对于消费方而言SaaS具有低成本、随时随地接入访问这些特性，再加上IT基础设施、安全技术等方面的成熟，SaaS将成为以后最主要的软件模式。</p><p>　　2、移动化。金蝶创始人徐少春在发布云之家的时候，把笔记本直接扔进垃圾桶了，说以后只使用手机办公，这虽然是一个噱头，但确实说明移动办公是个大趋势。</p><p>　　3、垂直化。前面说过，不同规模、不同阶段、不同行业的企业对企业应用的需求千差万别，企业内部中不同岗位、不同时段、不同职别的员工对企业应用的需求同样也千差万别，往往需要垂直细分到具体的行业才有可能做精，做更好的体验。</p><p>　　4、免费化。SaaS化、竞争白热化、周边资源可整合、软件边际成本趋零等这些原因会使得免费的企业级应用会越来越多。</p><p>　　5、合纵连横化。条件成熟，创业公司有机会崛起，BAT头巨头大举进入，在这个巨大的看似类似却又碎片化的领域，接下来我们会看到一场场合纵连横的好戏会不断上演。</p><p>　　6、更普及。以前信息化系统成本很高，往往只有大企业才有能力使用，现在条件成熟，投资机构热钱及创业者的热情投入，企业级应用空前繁荣，企业无论大小都能选择一款适合自己的应用。</p><p>　　涨姿势：几个概念</p><p>　　企业级应用。是指为商业组织、企业服务的应用系统，业内一般称为To B类应用，用于区别对个人类的应用（To C）。</p><p>　　APM是Application Performance Management &amp; Monitoring（应用性能管理 &amp; 监控）的简称，是用来监控和管理应用软件是否有效运行的，为上面据说的系统提供相关的监控。</p><p>　　EIP 是Enterprise Information Portal（企业信息门户）的简称，当一公司把前面所提到的OA、进销存、财务等等系统都使用上之后，使用人员需要在各个系统之间来回切换，非常麻烦低效，于是EIP就出现了，它就是把各种应用系统统一集成到一个入口系统中，在一平台时管理各个业务。</p><p>　　客服系统可以说是CRM系统的延伸，主要提供在线客服聊天、机器人客服、帮助文档、客户反馈等功能。</p><p>  <a href="http://www.cnblogs.com/tuyile006/p/5776061.html" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>swiftype账号与教程</title>
      <link href="/2016/03/21/swiftype%E8%B4%A6%E5%8F%B7%E4%B8%8E%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<p>　<br>首先，老一套的要去swiftype的网站<a href="https://swiftype.com注册一个账号，然后根据指引建立好自己网站对应的索引。" target="_blank" rel="noopener">https://swiftype.com注册一个账号，然后根据指引建立好自己网站对应的索引。</a><br>对了有人说注册以后是30天试用，这个没关系，网站给的是30天高级账户的使用<br>（那种有可以建立多个搜索引擎、多账户共同管理、一个引擎index多个域名的功能的账户），<br>30天到期后你可选择花钱继续用这个高级账户（土豪自便），或者选择降级成为免费的账户类型，<br>也就是我现在用的那种，所以，不用担心。<br>登陆后会自动切换到dashboard，一开始会有什么welcome to swiftype，不用搭理直接close即可。<br>然后下面的Create an engine选项便出现了，点吧，如图所示：</p><p><a href="https://github.com/ppoffice/hexo-theme-icarus/wiki/Search" target="_blank" rel="noopener">https://github.com/ppoffice/hexo-theme-icarus/wiki/Search</a><br><img src="http://www.jerryfu.net/img/search-engine-for-hexo-with-swiftype-v2/1.jpg" alt="此处输入图片的描述"><br>然后到下一步，给你的网站建立一个索引：<br><img src="http://www.jerryfu.net/img/search-engine-for-hexo-with-swiftype-v2/2.jpg" alt="此处输入图片的描述"><br>接着让你输入网址，写吧：<br><img src="http://www.jerryfu.net/img/search-engine-for-hexo-with-swiftype-v2/3.jpg" alt="此处输入图片的描述"><br>然后让你起个名字，起吧：<br><img src="http://www.jerryfu.net/img/search-engine-for-hexo-with-swiftype-v2/4.jpg" alt="此处输入图片的描述"><br>然后他开始抓取你网站的数据，等等吧：<br><img src="http://www.jerryfu.net/img/search-engine-for-hexo-with-swiftype-v2/5.jpg" alt="此处输入图片的描述"><br>抓好之后你的dashboard会变成这个样子：<br><img src="http://www.jerryfu.net/img/search-engine-for-hexo-with-swiftype-v2/6.jpg" alt="此处输入图片的描述"><br>可以点进去看看抓了些什么数据：<br><img src="http://www.jerryfu.net/img/search-engine-for-hexo-with-swiftype-v2/7.jpg" alt="此处输入图片的描述"><br><img src="http://www.jerryfu.net/img/search-engine-for-hexo-with-swiftype-v2/8.jpg" alt="此处输入图片的描述"><br>最后点击菜单的右边 interface 下的 install serarch<br>复制出key 即可。<br>然后打开 icarus配置搜索引擎的教程按教程即可<br><a href="https://github.com/ppoffice/hexo-theme-icarus/wiki/Search" target="_blank" rel="noopener">https://github.com/ppoffice/hexo-theme-icarus/wiki/Search</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>android开发的经验教训</title>
      <link href="/2016/03/11/android%E5%BC%80%E5%8F%91%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/"/>
      <content type="html"><![CDATA[<ol><li><p>在添加任何第三方party之前，请三思：这真的是一个成熟的项目吗？</p></li><li><p>如果一个东西用户看不到，<a href="http://riggaroo.co.za/optimizing-layouts-in-android-reducing-overdraw/" target="_blank" rel="noopener">就不要绘制它！</a></p></li><li><p>除非真的需要，否则别使用数据库；</p></li><li><p>达到65k方法数限制来的非常快，真的，非常快！不过 <a href="https://medium.com/@rotxed/dex-skys-the-limit-no-65k-methods-is-28e6cb40cf71" target="_blank" rel="noopener">multidexing 可以拯救你</a>;</p></li><li><p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a> 是 <a href="https://medium.com/swlh/party-tricks-with-rxjava-rxandroid-retrolambda-1b06ed7cd29c" target="_blank" rel="noopener">AsyncTasks</a> 以及其它杂碎的最佳替代者；</p></li><li><p><a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit</a> 可能是现在最佳的网络请求库；</p></li><li><p>使用 <a href="https://medium.com/android-news/retrolambda-on-android-191cc8151f85" target="_blank" rel="noopener">Retrolambda</a>来简化你的代码；</p></li><li><p>把 <a href="https://medium.com/swlh/party-tricks-with-rxjava-rxandroid-retrolambda-1b06ed7cd29c" target="_blank" rel="noopener">RxJava 和 Retrofit 以及 Retrolambda</a> 结合起来会让你酷炸天！</p></li><li><p>我使用 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a>而且它也很好，但是我并不会用太多，因为这样代码库会变得凌乱；</p></li><li><p><a href="https://medium.com/the-engineering-team/package-by-features-not-layers-2d076df1964d" target="_blank" rel="noopener">包名按照功能来，而不是按分层来</a>;</p></li><li><p>把所有东西都移到 application thread之外；</p></li><li><p><a href="http://developer.android.com/tools/help/layoutopt.html" target="_blank" rel="noopener">lint</a> 可以帮助你优化布局与布局树，这样你就能识别出那些可能已经被移除的冗余的View；</p></li><li><p>如果你在使用gradle，使用一切<a href="https://medium.com/the-engineering-team/speeding-up-gradle-builds-619c442113cb" target="_blank" rel="noopener">可能</a>的方式去加速它；</p></li><li><p>对builds做<a href="https://medium.com/the-engineering-team/speeding-up-gradle-builds-619c442113cb" target="_blank" rel="noopener">profile reports</a>，以便知道什么占据了编译时间；</p></li><li><p>使用一个 <a href="http://fernandocejas.com/2015/07/18/architecting-android-the-evolution/" target="_blank" rel="noopener">有名的</a> 架构；</p></li><li><p><a href="http://stackoverflow.com/a/67500/794485" target="_blank" rel="noopener">测试时比较花时间，但是一旦你找到诀窍它可以比不使用测试更快、更健壮</a>;</p></li><li><p>使用 <a href="http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/" target="_blank" rel="noopener">依赖注入</a> 让你的app更模块化，从而更易于测试；</p></li><li><p>收听 <a href="http://fragmentedpodcast.com/" target="_blank" rel="noopener">fragmented podcast</a> 将会让你受益；</p></li><li><p><a href="https://www.reddit.com/r/Android/comments/2hywu9/google_play_only_one_strike_is_needed_to_ruin_you/" target="_blank" rel="noopener">千万别用私人邮箱作为你安卓市场的发布者账号</a>;</p></li><li><p>总是使用<a href="http://developer.android.com/training/keyboard-input/style.html" target="_blank" rel="noopener">恰当的</a>输入类型；</p></li><li><p>Use analytics to find usage patterns and isolate bugs;</p></li><li><p>关注最新的 <a href="http://android-arsenal.com/" target="_blank" rel="noopener">libraries</a>（使用<a href="https://github.com/cesarferreira/dryrun" target="_blank" rel="noopener">dryrun</a> 来快速查看它们的的效果）</p></li><li><p>你的service应该做你所需的事情，并且尽快死去；</p></li><li><p>使用 <a href="http://developer.android.com/reference/android/accounts/AccountManager.html" target="_blank" rel="noopener">Account Manager</a> 来提示登录用户名和邮箱地址；</p></li><li><p>使用CI（持续集成）来构建和发布你的beta和产品apk；</p></li><li><p>不要运行自己的CIserver，维护server是费时的事情，因为磁盘空间，安全问题，更新server以防止SSL攻击等等原因。使用circleci, travis 或者 shippable, 它们便宜，而且你也可以少担心一些事情；</p></li><li><p>Automate your deployments to the playstore;</p></li><li><p>如果一个library很大而你只需要使用其中的一部分功能，你应该寻找一个更小的来替代（比如依靠<a href="http://developer.android.com/tools/help/proguard.html" target="_blank" rel="noopener">proguard</a> ）；</p></li><li><p>不要使用多于实际需要的module。从零开始编译一个module或者仅仅是检查上个module是否最新所需要的时间几乎是加载 binary .jar/.aar依赖的4倍以上；</p></li><li><p>开始<a href="http://developer.android.com/tools/help/vector-asset-studio.html" target="_blank" rel="noopener">考虑用SVG来替代PNG</a> ；</p></li><li><p>Make library abstraction classes, it’ll be way easier to switch to a new library if you only need to switch in one place (e.g.AppLogger.d(“message”) can contain Log.d(TAG, message) and later realise that Timber.d(message) is a better option);</p></li><li><p>监控你的连接情况以及连接类型（wifi之下更新更多数据？）；</p></li><li><p>监控你的电源和电量（在充电的时候更新更多的数据？电量低的时候暂停更新？）；</p></li><li><p>一个用户界面就如一个笑话那样，如果你需要解释，那么证明它并不够好；</p></li><li><p><a href="https://twitter.com/danlew42/status/677151453476032512" target="_blank" rel="noopener">Tests are great for performance: Write slow (but correct) implementation then verify optimizations don’t break anything with tests.</a></p></li></ol><p>原文：<a href="https://medium.com/@cesarmcferreira/building-android-apps-30-things-that-experience-made-me-learn-the-hard-way-313680430bf9#.6d0cbhkxa" target="_blank" rel="noopener">Building Android Apps — 30 things that experience made me learn the hard way。</a> </p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flex布局教程链接</title>
      <link href="/2016/03/09/Flex%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B%E9%93%BE%E6%8E%A5/"/>
      <content type="html"><![CDATA[<h1 id="Flex布局教程链接"><a href="#Flex布局教程链接" class="headerlink" title="Flex布局教程链接"></a>Flex布局教程链接</h1><p>[语法篇]<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$</a><br>[实例篇]<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式中类的关系</title>
      <link href="/2016/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <content type="html"><![CDATA[<p>在Java以及其他的面向对象设计模式中，类与类之间主要有6种关系，他们分别是：依赖、关联、聚合、组合、继承、实现。他们的耦合度依次增强。</p><ul><li>依赖（Dependence）<a href="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml1.gif" target="_blank" rel="noopener"><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml1.gif" alt=""></a><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml2.gif" alt=""><br>依赖关系的定义为：对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。定义比较晦涩难懂，但在java中的表现还是比较直观的：类A当中使用了类B，其中类B是作为类A的方法参数、方法中的局部变量、或者静态方法调用。类上面的图例中：People类依赖于Book类和Food类，Book类和Food类是作为类中方法的参数形式出现在People类中的。</li></ul><p><strong>代码样例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Book book)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"读的书是"</span>+book.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关联（Association）<img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml3.gif" alt=""><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml4.gif" alt=""><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml5.gif" alt=""><br><strong>单项关联：</strong><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml6.gif" alt=""><br><strong>双向关联：</strong><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml7.gif" alt=""></li></ul><p>对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。关联关系分为单向关联和双向关联。在java中，单向关联表现为：类A当中使用了类B，其中类B是作为类A的成员变量。双向关联表现为：类A当中使用了类B作为成员变量；同时类B中也使用了类A作为成员变量。</p><p><strong>代码样例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Father father = <span class="keyword">new</span> Father();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"从"</span>+father.getName()+<span class="string">"获得礼物"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Son son = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"从"</span>+son.getName()+<span class="string">"获得礼物"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>聚合（Aggregation）<img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml8.gif" alt=""><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml9.gif" alt=""></li></ul><p>聚合关系是关联关系的一种，耦合度强于关联，他们的代码表现是相同的，仅仅是在语义上有所区别：关联关系的对象间是相互独立的，而聚合关系的对象之间存在着包容关系，他们之间是“整体-个体”的相互关系。</p><p><strong>代码样例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Car car;</span><br><span class="line"></span><br><span class="line">House house;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouse</span><span class="params">(House house)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.house = house;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">driver</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"车型号:"</span>+car.getType());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"我在房子里睡觉:"</span>+house.getAddress());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>组合（Composition）<img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml10.gif" alt=""><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml11.gif" alt=""></li></ul><p>相比于聚合，组合是一种耦合度更强的关联关系。存在组合关系的类表示“整体-部分”的关联关系，“整体”负责“部分”的生命周期，他们之间是共生共死的；并且“部分”单独存在时没有任何意义。在下图的例子中，People与Soul、Body之间是组合关系，当人的生命周期开始时，必须同时有灵魂和肉体；当人的生命周期结束时，灵魂肉体随之消亡；无论是灵魂还是肉体，都不能单独存在，他们必须作为人的组成部分存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Soul soul;</span><br><span class="line"></span><br><span class="line">Body body;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(Soul soul,Body body)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.soul = soul;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.body = body;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"学习要灵魂:"</span>+soul.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"吃饭需要身体:"</span>+body.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继承（GeneraliZation）<img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml12.gif" alt=""><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml13.gif" alt=""></li></ul><p>继承表示类与类（或者接口与接口）之间的父子关系。在java中，用关键字extends表示继承关系。UML图例中，继承关系用实线+空心箭头表示，箭头指向父类。</p><ul><li>实现（Implementation）<img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml14.gif" alt=""><br><img src="https://github.com/mccappcom/DesignPattern/raw/master/assets/uml15.gif" alt=""></li></ul><p>表示一个类实现一个或多个接口的方法。接口定义好操作的集合，由实现类去完成接口的具体操作。在java中使用implements表示。UML图例中，实现关系用虚线+空心箭头表示，箭头指向接口。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>淘汰</title>
      <link href="/2015/12/17/%E6%B7%98%E6%B1%B0/"/>
      <content type="html"><![CDATA[<p>陈奕迅 - 淘汰<br>曲 : 周杰伦 词：周杰伦</p><p>我说了 所有的谎<br>你全都相信<br>简单的 我爱你<br>你却老不信<br>你书里的剧情<br>我不想上演<br>因为我喜欢 喜剧收尾</p><p>我试过 完美放弃<br>的确很踏实<br>醒来了<br>梦散了<br>你我都走散了<br>情歌歌词何必押韵<br>就算我是K歌之王<br>也不见得把 爱情唱得完美</p><p>只能说我输了<br>也许是你怕了<br>我们的回忆 没有皱褶<br>你却用离开烫下句点<br>只能说我认了<br>你的不安赢得你信任<br>我却得到你 安慰的淘汰</p><p>我试过完美放弃<br>的确很踏实<br>醒来了<br>梦散了<br>你我都走散了<br>情歌歌词何必押韵<br>就算我是K歌之王<br>也不见得把 爱情唱得完美</p><p>只能说我输了<br>也许是你怕了<br>我们的回忆 没有皱褶<br>你却用离开烫下句点<br>只能说我认了<br>你的不安赢得你信任<br>我却得到你 安慰的淘汰</p><p>只能说我输了<br>也许是你怕了<br>我们的回忆 没有皱褶<br>你却用离开烫下句点<br>只能说我认了<br>你的不安赢得你信任<br>我却得到你 安慰的淘汰</p>]]></content>
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 歌曲 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>七友</title>
      <link href="/2015/11/11/%E4%B8%83%E5%8F%8B/"/>
      <content type="html"><![CDATA[<p>梁汉文 - 七友<br>曲 : 雷颂德 词：林夕</p><p>为了她又再勉强去谈天论爱<br>又再振作去慰解他人<br>如难复合便尽早放开<br>凡事看开<br>又再讲没有情人时还可自爱<br>忘掉或是为自己感慨<br>笑住说沉沦那些苦海<br>会有害</p><p>因为我坚强到利用自己的痛心<br>转换成爱心<br>抵我对她操心<br>已记不起我也有权利爱人</p><p>谁人曾照顾过我的感受<br>待我温柔吻过我伤口<br>能得到的安慰是失恋者得救后<br>很感激忠诚的狗<br>谁人曾介意我也不好受<br>为我出头碰过我的手<br>重生者走得的都走<br>谁人又为天使忧愁<br>甜言蜜语没有但却有我这个好友</p><p>直到她又再告诉我重新被爱<br>又再看透了我的将来<br>完成任务后大可喝采<br>无谓搭台<br>别怪她就怪我永远难得被爱<br>然后自虐地赞她可爱<br>往日最彷徨那刻<br>好彩有我在</p><p>因为我坚强到利用自己的痛心<br>转换成爱心<br>抵我对她操心<br>已记不起我也有权利爱人</p><p>谁人曾照顾过我的感受<br>待我温柔吻过我伤口<br>能得到的安慰是失恋者得救后<br>很感激忠诚的狗<br>谁人曾介意我也不好受<br>为我出头碰过我的手<br>重生者走得的都走<br>谁人又为天使忧愁<br>甜言蜜语没有但却有我这个好友</p><p>白雪公主不多<br>认命扮矮人的有太多个<br>早有六个<br>多我这个不多<br>我太好心还是太傻<br>未问过她有没有理我的感受<br>待我温柔吻过我伤口<br>能得到的安慰是失恋者得救后<br>很感激忠诚的狗<br>谁人曾介意我也不好受<br>为我出头碰过我的手<br>重生者走得的都走<br>谁人又为天使忧愁<br>甜言蜜语没有但却有我这个好友</p>]]></content>
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 歌曲 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gradle目录解析</title>
      <link href="/2015/11/10/gradle%E7%9B%AE%E5%BD%95%E8%A7%A3%E6%9E%90/"/>
      <content type="html"><![CDATA[<blockquote><p>Gradle目录解析</p></blockquote><p>Gradle 是以 Groovy 语言为基础，面向Java应用为主。基于DSL（领域特定语言）语法的自动化构建工具。<br>Gradle这个工具集成了构建，测试，发布和其他，比如软件打包，生成注释文档等功能。<br>之前eclipse使用ant进行软件的构建功能，需要配置一大堆的xml，但是在gradle中就不需要了。</p><p>目前主流的打包方式有ant,maven,gradle。gradle是近几年发展起来的自动化构建工具，解决ant构建上的繁琐代码。<br>比如在ant上发布多渠道的包，你需要自己写脚本替换渠道名称，而在gradle中就不需要了。已经内建支持多渠道打包。</p><blockquote><p>Gradle的文件结构</p></blockquote><pre><code>./build.gradle./gradle.properties./gradlew./gradlew.bat./local.properties./setting.gradle./XXX.iml./app/build.gradle./app/app.iml./app/proguard-rules.pro</code></pre><p>./builld.gradle 和 ./app/build.grade</p><p>gradle项目自动编译的时候要读取的配置文件。比如指定项目的依赖包等。<br>build.grade有两个，一个是全局的，一个是在模块里面。<br>全局的build.grade主要设置的是声明仓库源，gradle的版本号说明等。</p><p>./build.gradle</p><pre><code>buildscript {repositories {    // 声明仓库源，比如我们构建了一个安卓的库，现在想要把库上传到jcenter中供别人一起使用，则可以上传到jcenter中    // 具体上传步骤见：http://www.jcodecraeer.com/a/anzhuokaifa/Android_Studio/2015/0227/2502.html    jcenter()}dependencies {    // 说明gradle的版本号    classpath &apos;com.android.tools.build:gradle:1.3.0&apos;    // NOTE: Do not place your application dependencies here; they belong    // in the individual module build.gradle files}}</code></pre><p>// 所有项目都继承这个配置</p><pre><code>    allprojects {    repositories {        mavenLocal()        jcenter()    }}</code></pre><p>./app/build.grade 设置了模块的gradle构建配置</p><pre><code>// 说明这个模块是安卓项目，如果是多模块开发，有可能有的值为java/war</code></pre><p>apply plugin: ‘com.android.application’</p><p>// 配置了所有android构建的参数<br>android {<br>    // 编译使用SDK版本<br>    compileSdkVersion 23<br>    // 编译工具的版本<br>    buildToolsVersion “23.0.1”</p><pre><code>defaultConfig {    // 包名    applicationId &quot;com.awesomeproject&quot;    // sdk最低支持版本    minSdkVersion 16    // 目标SDK版本，如果目标设备的API版本正好等于此数值，就不会为此程序开启兼容性检查判断的工作    targetSdkVersion 22    // 版本号    versionCode 1    versionName &quot;1.0&quot;    // 原生    ndk {        abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot;    }}buildTypes {    // 发布时候的设置    release {        // 是否进行混淆        minifyEnabled false        // 混淆使用文件        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;    }}}// 依赖的工具包dependencies {compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])compile &apos;com.android.support:appcompat-v7:23.0.0&apos;compile &apos;com.facebook.react:react-native:0.11.+&apos;}./app/proguard-rules.pro这个和上面说的一样混淆文件./gradle.propertiesgrade的运行环境配置，比如使用多少内存之类的。./gradlew 和 ./gradlew.bat自动完成 gradle 环境的脚本，在linux和mac下直接运行gradlew会自动完成gradle环境的搭建。./local.properties配置SDK或者NDK的环境路径，各个机器上这个变量可能都是不一样的，所以不应该进入版本库./setting.gradle整个项目的管理，比如这个项目包含哪些模块等。./XXX.iml 和 ./app/app.imliml是Intellij模块文件。Intellij是一款JAVA的IDE。AndroidStudio是基于开源的Intellij IDEA开发出来的IDE。所以AndroidStudio有的IDE功能是需要有.iml才能使用的。比如我们删除了iml文件，可能就在Android Studio中看不到一些目录了。</code></pre>]]></content>
      
      <categories>
          
          <category> gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java对象四大引用</title>
      <link href="/2015/09/22/java%E5%AF%B9%E8%B1%A1%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/"/>
      <content type="html"><![CDATA[<blockquote><p>强引用、软引用、弱引用、虚引用总结</p></blockquote><pre><code>总结：</code></pre><ol><li>强引用(StrongReference)：普通new对象的引用<pre><code>Person person  = new Person();JVM宁愿抛出OutOfMenory异常也不会去回收该对象。</code></pre></li><li>软引用(SoftReference)：<br> SoftReference引用的装饰对象，该对象的强引用应该赋值空<br>这里配合SoftReferenceQueue使用(也可以配合),因为SoftRefereceQueue本身也是new了一个对象，当它把别人的问题解决掉以后，也需要自己的问题解决，所有jvm把软引用对象回收后，就会把自己的对象引用放到这个队列中，我们可以通过队列的poll()方法查看,如果存在该ReferenceQueue引用也赋值为空，等待被jvm回收。注意：软引用对象在jvm内存不够的时候才会被回收，我们调用system.gc方法只是起通知作用，jvm什么时候扫描回收对象，是jvm自己的状态决定的。就算扫描到软引用对象也不一定回收。只有内存不够的时候才会回收<br>ReferenceQueue queue = new ReferenceQueue();<br>Person person = new Person();<br>SoftReference soft = new SoftReference(person,queue);<br>user = null;</li><li>弱引用(WeakReference)：弱引用也是用描述非必需对象的，当jvm进行垃圾回收时，只要扫描到，无论内存是否充足(与软引用的区别)，都会回收弱引用关联的对象。在java中，用java.lang.ref.WeakReference类表示<br>WeakReference<person> weak = new WeakRefence<person>(new Person());<br>System.out.println(weak.get());<br>System.gc();//通知jvm的gc进行垃圾回收<br>System.out.println(weak.get());</person></person></li><li>虚引用(PhantomReference)：<br>虚引用和前面的软引用，弱引用不同，它并不影响对象的生命周期。<br>在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。要注意的是，虚引用必须和引用队列关联使用，当垃圾回收准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入引用队列，那么就可以在所引用的对象内存被回收之前采取必要的行动。<br>ReferenceQueue queue = new ReferenceQueue();<br>PhantomReference<person> prf = new PhantomReference<person>(new Person(),queue);<br>System.out.print(prf.get());<br><a href="http://www.cnblogs.com/dolphin0520/p/3741519.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3741519.html</a><br><a href="http://www.cnblogs.com/dolphin0520/p/3749259.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3749259.html</a></person></person></li></ol>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 正则表达式</title>
      <link href="/2015/09/22/android-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <content type="html"><![CDATA[<blockquote><p>android正则表达式及Pattern Matcher使用</p></blockquote><pre><code>// 反斜杠/t 间隔 (&apos;/u0009&apos;)/n 换行 (&apos;/u000A&apos;)/r 回车 (&apos;/u000D&apos;)/d 数字 等价于[0-9]/D 非数字 等价于[^0-9]/s 空白符号 [/t/n/x0B/f/r]/S 非空白符号 [^/t/n/x0B/f/r]/w 单独字符 [a-zA-Z_0-9]/W 非单独字符 [^a-zA-Z_0-9]/f 换页符/e Escape/b 一个单词的边界/B 一个非单词的边界/G 前一个匹配的结束^为限制开头^java     条件限制为以Java为开头字符$为限制结尾java$     条件限制为以java为结尾字符.  条件限制除/n以外任意一个单独字符java..     条件限制为java后除换行外任意两个字符加入特定限制条件「[]」[a-z]     条件限制在小写a to z范围中一个字符[A-Z]     条件限制在大写A to Z范围中一个字符[a-zA-Z] 条件限制在小写a to z或大写A to Z范围中一个字符[0-9]     条件限制在小写0 to 9范围中一个字符[0-9a-z] 条件限制在小写0 to 9或a to z范围中一个字符[0-9[a-z]] 条件限制在小写0 to 9或a to z范围中一个字符(交集)[]中加入^后加再次限制条件「[^]」[^a-z]     条件限制在非小写a to z范围中一个字符[^A-Z]     条件限制在非大写A to Z范围中一个字符[^a-zA-Z] 条件限制在非小写a to z或大写A to Z范围中一个字符[^0-9]     条件限制在非小写0 to 9范围中一个字符[^0-9a-z] 条件限制在非小写0 to 9或a to z范围中一个字符[^0-9[a-z]] 条件限制在非小写0 to 9或a to z范围中一个字符(交集)在限制条件为特定字符出现0次以上时，可以使用「*」J*     0个以上J.*     0个以上任意字符J.*D     J与D之间0个以上任意字符在限制条件为特定字符出现1次以上时，可以使用「+」J+     1个以上J.+     1个以上任意字符J.+D     J与D之间1个以上任意字符在限制条件为特定字符出现有0或1次以上时，可以使用「?」JA? J或者JA出现限制为连续出现指定次数字符「{a}」J{2}     JJJ{3}     JJJ文字a个以上，并且「{a,}」J{3,}     JJJ,JJJJ,JJJJJ,???(3次以上J并存)文字个以上，b个以下「{a,b}」J{3,5}     JJJ或JJJJ或JJJJJ两者取一「|」J|A     J或AJava|Hello     Java或Hello</code></pre><blockquote><p>比如，在字符串包含验证时</p></blockquote><pre><code>//查找以Java开头,任意结尾的字符串Pattern pattern  = Pattern.compile(&quot;^Java.*&quot;);Matcher matcher = pattern.matcher(&quot;Java棒棒的&quot;);boolean bool = matcher.matches();System.out.println(bool); //true//以多条件分割字符串时Pattern pattern = Pattern.compile(&quot;[,|]+&quot;);String[] strs = pattern.split(&quot;Java Hello World  Java,Hello,,World|Sun&quot;);for (int i=0;i&lt;strs.length;i++) {   System.out.println(strs[i]);   //Java Hello World  Java//Hello//World//Sun}  //文字替换（首次出现字符）Pattern pattern = Pattern.compile(&quot;正则表达式&quot;);  Matcher matcher = pattern.matcher(&quot;正则表达式 Hello World,正则表达式 Hello       World&quot;);  //替换第一个符合正则的数据  System.out.println(matcher.replaceFirst(&quot;Java&quot;));  //Java Hello World,正则表达式 Hello//文字替换（全部）Pattern pattern = Pattern.compile(&quot;正则表达式&quot;);  Matcher matcher = pattern.matcher(&quot;正则表达式 Hello World,正则表达式 Hello       World&quot;);  //替换第一个符合正则的数据  System.out.println(matcher.replaceAll(&quot;Java&quot;));  //Java Hello World,Java Hello//◆文字替换（置换字符） Pattern pattern = Pattern.compile(&quot;正则表达式&quot;); Matcher matcher = pattern.matcher(&quot;正则表达式 Hello World,正则表达式 Hello World &quot;); StringBuffer sbr = new StringBuffer(); while (matcher.find()) {        matcher.appendReplacement(sbr, &quot;Java&quot;); } matcher.appendTail(sbr); System.out.println(sbr.toString()); //Java Hello World,Java Hello World  //验证是否为邮箱地址 String str=&quot;ceponline@yahoo.com.cn&quot;;   Pattern pattern =   Pattern.compile(&quot;[//w//.//-]+@([//w//-]+//.)+[//w//-]+&quot;,Pattern.CASE_INSENSI TIVE);   Matcher matcher = pattern.matcher(str); System.out.println(matcher.matches());  //true//去除html标记 Pattern pattern = Pattern.compile(&quot;&lt;.+?&gt;&quot;, Pattern.DOTALL);   Matcher matcher = pattern.matcher(&quot;&lt;a href=/&quot;index.html/&quot;&gt;主页&lt;/a&gt;&quot;);   String string = matcher.replaceAll(&quot;&quot;);   System.out.println(string); //主页//查找html中对应条件字符串Pattern pattern = Pattern.compile(&quot;href=\&quot;(.+?)\&quot;&quot;);Matcher matcher = pattern.matcher(&quot;&lt;a href=\&quot;index.html\&quot;&gt;主页&lt;/a&gt;&quot;);if(matcher.find())System.out.println(matcher.group(1));//index.html//截取http://地址Pattern pattern = Pattern.compile(&quot;(http://|https://){1}[//w//.//-/:]+&quot;);  Matcher matcher = pattern.matcher(&quot;dsdsds&lt;http://dsds//gfgffdfd&gt;fdf&quot;);  StringBuffer buffer = new StringBuffer();  while(matcher.find()){                buffer.append(matcher.group());          buffer.append(&quot;/r/n&quot;);                System.out.println(buffer.toString());  }  //替换指定{}中文字String str = &quot;Java目前的发展史是由{0}年-{1}年&quot;;  String[][] object={new String[]{&quot;//{0//}&quot;,&quot;1995&quot;},new String[]{&quot;//{1//}&quot;,&quot;2007&quot;}};  System.out.println(replace(str,object));  public static String replace(final String sourceString,Object[] object) {          String temp=sourceString;              for(int i=0;i&lt;object.length;i++){                    String[] result=(String[])object[i];             Pattern    pattern = Pattern.compile(result[0]);             Matcher matcher = pattern.matcher(temp);             temp=matcher.replaceAll(result[1]);          }          return temp;          }  //Java目前的发展史是由1995年-2007年</code></pre>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git基础学习一</title>
      <link href="/2015/09/21/git%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
      <content type="html"><![CDATA[<blockquote><p>git常用命令</p></blockquote><ol><li>git mkdir xx(创建xx文件夹) cd xx(切换到xx文件夹) </li><li>touch a.md(新建a.md文件)</li><li>gitstatus (查看git文件内容状态) </li><li>git init(初始化仓库)</li><li>git add xx(添加xx文件到暂存区) git add . (添加所有文件到暂存区)</li><li>git commit -m”content”(content 提交内容留言)</li><li>git log (查看日志)</li><li>git branch (查看分支，* master是默认分支)</li><li>git branch a (新建名为a的分支)</li><li>git checkout a (切换到名为a的分支 快捷方式 git checkout -b a 新建a分支并切换到该分支)</li><li>git merge (分支合并 切换到主分支 再执行 git merge a 将a分支合并到主分支上)</li><li>git branch -d a (删除a分支)</li><li>git branch -D a (执行 branch -d a 删除失败，比如a分支未合并到主分支上，git branch -D a就是执行强制删除)</li><li>git tag v1.0(创建标签v1.0版本。标签，用于标记版本。切换某版本 git checkout v1.0)</li></ol><blockquote><p>PUSH&amp;PUll</p></blockquote><ol><li>git push origin master (推代码到远程仓库)</li><li>git pull origin master (拉代码到本地)</li><li>git clone git@github.com:mccapp/test.git (将远程代码复制到本地)</li><li>git remote add origin git@github.com:mccapp/test.git (将本地项目与github上的项目进行关联)</li><li>git remote -v (查看有那些远程仓库)</li><li>git config –blobal user.name “mccapp” (设置github用户名)</li><li>git config –blobal user.email  “rsinn@sina.com”(设置邮箱)</li></ol><blockquote><p>git进阶<br> <a href="http://stormzhang.com/github/2016/06/16/learn-github-from-zero5/" target="_blank" rel="noopener">进阶链接</a></p></blockquote><p><a href="http://stormzhang.com/github/2016/07/09/learn-from-github-from-zero6/" target="_blank" rel="noopener">团队合作git</a><br><a href="http://blog.csdn.net/column/details/retrofit.html" target="_blank" rel="noopener">rxjava进阶教程</a></p>]]></content>
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git基础学习二</title>
      <link href="/2015/09/21/git%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%BA%8C/"/>
      <content type="html"><![CDATA[<blockquote><p>git常用命令</p></blockquote><p>1) 远程仓库相关命令</p><p>检出仓库：$ git clone git://github.com/jquery/jquery.git<br>查看远程仓库：$ git remote -v<br>添加远程仓库：$ git remote add [name] [url]<br>删除远程仓库：$ git remote rm [name]<br>修改远程仓库：$ git remote set-url –push[name][newUrl]<br>拉取远程仓库：$ git pull [remoteName] [localBranchName]<br>推送远程仓库：$ git push [remoteName] [localBranchName]</p><p>2）分支(branch)操作相关命令</p><p>查看本地分支：$ git branch<br>查看远程分支：$ git branch -r<br>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支<br>切换分支：$ git checkout [name]<br>创建新分支并立即切换到新分支：$ git checkout -b [name]<br>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项<br>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并<br>创建远程分支(本地分支push到远程)：$ git push origin [name]<br>删除远程分支：$ git push origin :heads/[name]<br>我从master分支创建了一个issue5560分支，做了一些修改后，使用git push origin master提交，但是显示的结果却是’Everything up-to-date’，发生问题的原因是git push origin master 在没有track远程分支的本地分支中默认提交的master分支，因为master分支默认指向了origin master 分支，这里要使用git push origin issue5560：master 就可以把issue5560推送到远程的master分支了。<br>如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。</p><p>$ git push origin test:master // 提交本地test分支作为远程的master分支 //好像只写这一句，远程的github就会自动创建一个test分支<br>$ git push origin test:test // 提交本地test分支作为远程的test分支</p><p>如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。</p><p>$ git push origin :test // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心</p><p>3）版本(tag)操作相关命令</p><p>查看版本：$ git tag<br>创建版本：$ git tag [name]<br>删除版本：$ git tag -d [name]<br>查看远程版本：$ git tag -r<br>创建远程版本(本地版本push到远程)：$ git push origin [name]<br>删除远程版本：$ git push origin :refs/tags/[name]<br>推送所有tag: git push origin –tags</p><p>tag迁出branch：<br>git checkout tagname<br>git checkout -b new_branch_name</p><p>4）git stash暂存相关命令</p><p>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。<br>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。<br>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。<br>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</p><p>5）git rebase 使用</p><p>当前分支问题develop，从master拉取最新代码<br>git pull –rebase origin master 或者 git rebase develop<br>先将develop分支的代码checkout出来，作为工作目录<br>然后将master分支从develop分支创建起的所有改变的补丁，依次打上。如果打补丁的过程没问题，rebase就搞定了<br>如果打补丁的时候出现了问题，就会提示你处理冲突。处理好了，可以运行git rebase –continue继续直到完成<br>如果你不想处理，你还是有两个选择，一个是放弃rebase过程（运行git rebase –abort），另一个是直接用test分支的取代当前分支的（git rebase –skip）。</p><p>6） 工具</p><p>  SourceTree &amp; git bash</p><blockquote><p>git进阶<br> <a href="http://stormzhang.com/github/2016/06/16/learn-github-from-zero5/" target="_blank" rel="noopener">进阶链接</a></p></blockquote><p><a href="http://stormzhang.com/github/2016/07/09/learn-from-github-from-zero6/" target="_blank" rel="noopener">团队合作git</a><br><a href="http://blog.csdn.net/column/details/retrofit.html" target="_blank" rel="noopener">rxjava进阶教程</a></p>]]></content>
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式</title>
      <link href="/2015/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/588785-c235ddbcaa1614a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表示关系的UML标记"></p><blockquote><p>24种设计模式</p></blockquote><ol><li>代理模式<br>在某些情况下，我们不希望或是不能直接访问对象 A，而是通过访问一个中介对象 B，由 B 去访问 A 达成目的，这种方式我们就称为代理。<br>这里对象 A 所属类我们称为委托类，也称为被代理类，对象 B 所属类称为代理类。</li><li><p>优点<br> 隐藏委托类的实现<br>解耦，不改变委托类代码的情况下做一些额外处理，比如添加初始判断及其他公共操作<br>根据程序运行前代理类是否已经存在，可以将代理分为静态代理和动态代理。<br> 代理类在程序运行前已存在的代理方式称为静态代理。<br>代理类在程序运行前未存在的代理、运行时由程序动态生成的代理方式称为动态代理。</p></li><li><p>静态代理<br> 由开发人员编写或是编译器生成代理类的方式属于静态代理。</p></li><li><p>动态代理<br> 三步骤:<br> 1.新建委托类<br>public interface Operate {</p><pre><code>public void operateMethod1();public void operateMethod2();public void operateMethod3();</code></pre><p>}</p><p>public class OperateImpl implements Operate {</p><pre><code>@Overridepublic void operateMethod1() {    System.out.println(&quot;Invoke operateMethod1&quot;);    sleep(110);}@Overridepublic void operateMethod2() {    System.out.println(&quot;Invoke operateMethod2&quot;);    sleep(120);}@Overridepublic void operateMethod3() {    System.out.println(&quot;Invoke operateMethod3&quot;);    sleep(130);}private static void sleep(long millSeconds) {    try {        Thread.sleep(millSeconds);    } catch (InterruptedException e) {        e.printStackTrace();    }}</code></pre><p>}<br>2.实现InvocationHandler接口，这是负责连接代理类与委托类的中间类必须实现的接口<br>public class TimingInvocationHandler implements InvocationHandler {</p><pre><code>private Object target;public TimingInvocationHandler() {}public TimingInvocationHandler(Object target) {    this.target = target;}@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    long start = System.currentTimeMillis();    Object obj = method.invoke(target, args);    System.out.println(method.getName() + &quot; cost time is:&quot; + (System.currentTimeMillis() - start));    return obj;}</code></pre><p>}</p></li></ol><pre><code>3.通过Proxy类新建代理类对象    public class Main {        public static void main(String[] args) {            // create proxy instance            TimingInvocationHandler timingInvocationHandler = new         TimingInvocationHandler(new OperateImpl()); Operate operate = (Operate)(Proxy.newProxyInstance(Operate.class.getClassLoader(), new Class[] {Operate.class},timingInvocationHandler));            // call method of proxy instance            operate.operateMethod1();            System.out.println();            operate.operateMethod2();            System.out.println();            operate.operateMethod3();        }    }</code></pre><ol><li><p>应用场景<br> 作用：目标函数值之间的耦合<br>比如在 Dao 中，每次数据库操作都需要开启事务，而且在操作的时候需要关注权限。一般写法是在 Dao 的每个函数中添加相应逻辑，造成代码冗余，耦合度高。<br>使用动态代理前伪代码如下：</p><pre><code>Dao {insert() {    判断是否有保存的权限；    开启事务；    插入；    提交事务；}delete() {    判断是否有删除的权限；    开启事务；    删除；    提交事务；}</code></pre><p>}<br>使用动态代理的伪代码如下：<br>使用动态代理，组合每个切面的函数，而每个切面只需要关注自己的逻辑就行，达到减少代码，松耦合的效果</p></li></ol><pre><code>invoke(Object proxy, Method method, Object[] args)                        throws Throwable {        判断是否有权限；        开启事务；        Object ob = method.invoke(dao, args)；        提交事务；        return ob;     }</code></pre><p>6.基于 REST 的 Android 端网络请求框架 Retrofit<br>作用：简化网络请求操作。<br>一般情况下每个网络请求我们都需要调用一次HttpURLConnection或者HttpClient进行请求，或者像 Volley 一样丢进等待队列中，Retrofit 极大程度简化了这些操作，示例代码如下：</p><pre><code>   public interface GitHubService {      @GET(&quot;/users/{user}/repos&quot;)      List&lt;Repo&gt; listRepos(@Path(&quot;user&quot;) String user);    }    RestAdapter restAdapter = new RestAdapter.Builder().setEndpoint(&quot;https://api.github.com&quot;).build();GitHubService service = restAdapter.create(GitHubService.class); 以后我们只需要直接调用List&lt;Repo&gt; repos = service.listRepos(&quot;octocat&quot;);</code></pre><p><a href="http://blog.csdn.net/woliuyunyicai/article/details/51381807" target="_blank" rel="noopener">设计模式汇总</a></p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象16种设计原则</title>
      <link href="/2015/06/12/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A116%E7%A7%8D%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <content type="html"><![CDATA[<blockquote><p>一   类的设计原则</p></blockquote><p>1　依赖倒置原则－Dependency Inversion Principle (DIP)<br>2　里氏替换原则－Liskov Substitution Principle (LSP)<br>3　接口分隔原则－Interface Segregation Principle (ISP)<br>4　单一职责原则－Single Responsibility Principle (SRP)<br>5　开闭原则－The Open-Closed Principle (OCP)</p><blockquote><p>二  包的设计原则</p></blockquote><p>6　重用发布等价原则－Release ReuseEquivalency Principle (REP)<br>7　无环依赖原则－The AcyclicDependencies Principle (ADP)<br>8　稳定依赖原则－The StableDependencies Principle (SDP)<br>9　稳定抽象等价原则－The StableAbstractions Principle (SAP)<br>10　共同封闭原则－The CommonClosure Principle (CCP)<br>11　全部重用原则－The Common Reuse Principle (CRP)</p><blockquote><p>三  扩展原则</p></blockquote><p>12  迪米特法则 －Least Knowledge Principle (LKP)<br>13  黑盒原则－ BBP(Black Box Principle)<br>14  缺省抽象原则 －DAP(Default Abstraction Principle)<br>15  接口设计原则 －IDP(Interface Design Principle)<br>16  不要构造具体的超类原则 －DCSP(Don’t Concrete SupperclassPrinciple)</p><blockquote><ol><li>Dependency Inversion Principle (DIP) - 依赖倒置原则</li></ol></blockquote><p>依赖：在程序设计中，如果一个模块a使用或调用了另一个模块b，我们称模块a依赖模块b。<br>高层模块与低层模块：往往在一个应用程序中，我们有一些低层次的类，这些类实现了一些基本的或初级的操作，我们称之为低层模块；另外有一些高层次的类，这些类封装了某些复杂的逻辑，并且依赖于低层次的类，这些类我们称之为高层模块。</p><blockquote><p>依赖倒置原则的2个重要方针：</p></blockquote><ol><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</li><li>抽象不应该依赖于细节，细节应该依赖于抽象</li></ol><blockquote><p>为什么叫做依赖倒置（Dependency Inversion）呢？</p></blockquote><p>面向对象程序设计相对于面向过程（结构化）程序设计而言，依赖关系被倒置了。因为传统的结构化程序设计中，高层模块总是依赖于低层模块。</p><p>问题的提出：</p><p>Robert C. Martin在原文中给出了“Bad Design”的定义：</p><ol><li>系统很难改变，因为每个改变都会影响其他很多部分。</li><li>当你对某地方做一修改，系统的看似无关的其他部分都不工作了。</li><li>系统很难被另外一个应用重用，因为你很难将要重用的部分从系统中分离开来。</li></ol><p>导致“Bad Design”的很大原因是“高层模块”过分依赖“低层模块”。一个良好的设计应该是系统的每一部分都是可替换的。如果“高层模块”过分依赖“低层模块”，一方面一旦“低层模块”需要替换或者修改，“高层模块”将受到影响；另一方面，高层模块很难可以重用。</p><p>比如，一个Copy模块，需要把来自Keyboard的输入复制到Print，即使对Keyboard和Print的封装已经做得非常好，但如果Copy模块里直接使用Keyboard与Print，Copy任很难被其他应用环境（比如需要输出到磁盘时）重用。</p><blockquote><p>问题的解决：</p></blockquote><p>为了解决上述问题，Robert C. Martin提出了OO设计的Dependency Inversion Principle (DIP) 原则。<br>DIP给出了一个解决方案：在高层模块与低层模块之间，引入一个抽象接口层。<br>High Level Classes（高层模块） –&gt; Abstraction Layer（抽象接口层） –&gt; Low Level Classes（低层模块）<br>抽象接口是对低层模块的抽象，低层模块继承或实现该抽象接口。<br>这样，高层模块不直接依赖低层模块，高层模块与低层模块都依赖抽象接口层。<br>当然，抽象也不依赖低层模块的实现细节，低层模块依赖（继承或实现）抽象定义。</p><blockquote><p>Robert C. Martin给出的DIP方案的类的结构图：</p></blockquote><p>PolicyLayer–&gt;MechanismInterface(abstract)–MechanismLayer–&gt;UtilityInterface(abstract)–UtilityLayer<br>类与类之间都通过Abstract Layer来组合关系。</p><ol><li>Liskov Substitution Principle (LSP) - 里氏替换原则</li></ol><p>所有引用基类的地方必须能透明地使用其子类的对象。也就是说，只有满足以下2个条件的OO设计才可被认为是满足了LSP原则：<br>A  不应该在代码中出现if/else之类对子类类型进行判断的条件。以下代码就违反LSP定义。</p><pre><code>if (obj typeof Class1) {     do something} else if (obj typeof Class2) {     do something else}</code></pre><p>B  子类应当可以替换父类并出现在父类能够出现的任何地方，或者说如果我们把代码中使用基类的地方用它的子类所代替，代码还能正常工作。</p><blockquote><p>里氏替换原则LSP是使代码符合开闭原则的一个重要保证。同时LSP体现了：</p></blockquote><p>1） 类的继承原则：如果一个继承类的对象可能会在基类出现地方出现运行错误，则该子类不应该从该基类继承，或者说，应该重新设计它们之间的关系。<br>2）动作正确性保证：从另一个侧面上保证了符合LSP设计原则的类的扩展不会给已有的系统引入新的错误。</p><blockquote><p>类的继承原则：</p></blockquote><p>Robert C. Martin举了Rectangle和Square的例子。这里沿用这个例子，但用Java语言对其加以重写，并忽略了某些细节只列出下面的精要部分来说明 里氏替换原则 对类的继承上的约束。</p><pre><code>class Rectangle {       double width;       double height;       public double getHeight() {           return height;        }       public void setHeight(double height) {           this.height = height;        }       public double getWidth() {           return width;        }       public void setWidth(double width) {           this.width = width;        }      }   class Square extends Rectangle {       public void setHeight(double height) {           super.setHeight(height);           super.setWidth(height);        }       public void setWidth(double width) {           super.setHeight(width);           super.setWidth(width);        }   }  class Rectangle {      double width;      double height;      public double getHeight() {          return height;      }      public void setHeight(double height) {          this.height = height;      }      public double getWidth() {          return width;      }      public void setWidth(double width) {          this.width = width;      }    }class Square extends Rectangle {      public void setHeight(double height) {          super.setHeight(height);          super.setWidth(height);      }      public void setWidth(double width) {          super.setHeight(width);          super.setWidth(width);      }}</code></pre><blockquote><p>这里Rectangle是基类，Square从Rectangle继承。这种继承关系有什么问题吗？</p></blockquote><p>假如已有的系统中存在以下既有的业务逻辑代码：</p><pre><code>void g(Rectangle r) {     r.setWidth(5);     r.setHeight(4);     if (r.getWidth() * r.getHeight() != 20) {         throw new RuntimeException();     }}</code></pre><p>则对应于扩展类Square，在调用既有业务逻辑时：<br>         Rectangle square = new Square();<br>         g(square);<br>时会抛出一个RuntimeException异常。这显然违反了LSP原则。</p><blockquote><p>动作正确性保证：</p></blockquote><p>因为LSP对子类的约束，所以为已存在的类做扩展构造一个新的子类时，根据LSP的定义，不会给已有的系统引入新的错误。<br>Design by Contract<br>         根据Bertrand Meyer提出的Design by Contract（DBC：基于合同的设计）概念的描述，对于类的一个方法，都有一个前提条件以及一个后续条件，前提条件说明方法接受什么样的参数数据等，只有前提条件得到满足时，这个方法才能被调用；同时后续条件用来说明这个方法完成时的状态，如果一个方法的执行会导致这个方法的后续条件不成立，那么此方法也不应该正常返回。<br>         现在把前提条件以及后续条件应用到继承子类中，子类方法应该满足：<br>１）前提条件不强于基类．<br>２）后续条件不弱于基类．<br>        换句话说，通过基类的接口调用一个对象时，用户只知道基类前提条件以及后续条件。因此继承类不得要求用户提供比基类方法要求的更强的前提条件，亦即，继承类方法必须接受任何基类方法能接受的任何条件（参数）。同样，继承类必须顺从基类的所有后续条件，亦即，继承类方法的行为和输出不得违反由基类建立起来的任何约束，不能让用户对继承类方法的输出感到困惑。这样，我们就有了基于合同的LSP，基于合同的LSP是LSP的一种强化。</p><p>在很多情况下，在设计初期我们类之间的关系不是很明确，LSP则给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系。</p><blockquote><ol><li>Interface Segregation Principle (ISP) - 接口分隔原则</li></ol></blockquote><p>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。它包含了2层意思：<br>1）接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户不使用的方法塞进同一个接口里。<br>   如果一个接口的方法没有被使用到，则说明该接口过胖，应该将其分割成几个功能专一的接口。<br>2）接口的依赖（继承）原则：如果一个接口a依赖（继承）另一个接口b，则接口a相当于继承了接口b的方法，那么继承了接口b后的接口a也应该遵循上述原则：不应该包含用户不使用的方法。   反之，则说明接口a被b给污染了，应该重新设计它们的关系。</p><p>如果用户被迫依赖他们不使用的接口，当接口发生改变时，他们也不得不跟着改变。换而言之，一个用户依赖了未使用但被其他用户使用的接口，当其他用户修改该接口时，依赖该接口的所有用户都将受到影响。这显然违反了开闭原则，也不是我们所期望的。</p><p>下面我们举例说明怎么设计接口或类之间的关系，使其不违反ISP原则。<br>假如有一个Door，有lock，unlock功能，另外，可以在Door上安装一个Alarm而使其具有报警功能。用户可以选择一般的Door，也可以选择具有报警功能的Door。</p><blockquote><p>有以下几种设计方法： ISP原则的违反例：</p></blockquote><p><strong>方法一：</strong><br>在Door接口里定义所有的方法。图：<br>但这样一来，依赖Door接口的CommonDoor却不得不实现未使用的alarm()方法。违反了ISP原则。</p><p><strong>方法二：</strong><br>在Alarm接口定义alarm方法，在Door接口定义lock，unlock方法，Door接口继承Alarm接口。</p><p>跟方法一一样，依赖Door接口的CommonDoor却不得不实现未使用的alarm()方法。违反了ISP原则。<br>遵循ISP原则的例：</p><p><strong>方法三：通过多重继承实现</strong><br>Adapter设计模式的实现。<br>第2）种方案更具有实用性。<br>这种设计遵循了ISP设计原则。</p><p><strong>方法四：通过委托实现</strong><br>在Alarm接口定义alarm方法，在Door接口定义lock，unlock方法。接口之间无继承关系。CommonDoor实现Door接口，<br>AlarmDoor有2种实现方案：<br>1）同时实现Door和Alarm接口。<br>2）继承CommonDoor，并实现Alarm接口。该方案是继承方式的<br>小结<br>Interface Segregation Principle (ISP)从对接口的使用上为我们对接口抽象的颗粒度建立了判断基准：在为系统设计接口的时候，使用多个专门的接口代替单一的胖接口。</p><blockquote><ol><li>Single Responsibility Principle (SRP) - 单一职责原则</li></ol></blockquote><p>永远不要让一个类存在多个改变的理由。换句话说，如果一个类需要改变，改变它的理由永远只有一个。如果存在多个改变它的理由，就需要重新设计该类。</p><p>SRP（Single Responsibility Principle）原则的核心含意是：只能让一个类有且仅有一个职责。这也是单一职责原则的命名含义。</p><blockquote><p>为什么一个类不能有多于一个以上的职责呢？</p></blockquote><p>如果一个类具有一个以上的职责，那么就会有多个不同的原因引起该类变化，而这种变化将影响到该类不同职责的使用者（不同用户）：<br>1，一方面，如果一个职责使用了外部类库，则使用另外一个职责的用户却也不得不包含这个未被使用的外部类库。<br>2，另一方面，某个用户由于某原因需要修改其中一个职责，另外一个职责的用户也将受到影响，他将不得不重新编译和配置。这违反了设计的开闭原则，也不是我们所期望的。</p><p>职责的划分<br>既然一个类不能有多个职责，那么怎么划分职责呢？<br>Robert.C Martin给出了一个著名的定义：所谓一个类的一个职责是指引起该类变化的一个原因。如果你能想到一个类存在多个使其改变的原因，那么这个类就存在多个职责。</p><p>Single Responsibility Principle (SRP)的原文里举了一个Modem的例子来说明怎么样进行职责的划分，这里我们也沿用这个例子来说明一下：</p><p>SRP违反例：</p><pre><code>Modem.javainterface Modem {     public void dial(String pno);     //拨号     public void hangup();         //挂断     public void send(char c);     //发送数据     public char recv();         //接收数据}</code></pre><p>咋一看，这是一个没有任何问题的接口设计。但事实上，这个接口包含了2个职责：第一个是连接管理（dial, hangup）；另一个是数据通信（send, recv）。很多情况下，这2个职责没有任何共通的部分，它们因为不同的理由而改变，被不同部分的程序调用。<br>所以它违反了SRP原则。</p><p>下面的类图将它的2个不同职责分成2个不同的接口，这样至少可以让客户端应用程序使用具有单一职责的接口：<br>让ModemImplementation实现这两个接口。我们注意到，ModemImplementation又组合了2个职责，这不是我们希望的，但有时这又是必须的。通常由于某些原因，迫使我们不得不绑定多个职责到一个类中，但我们至少可以通过接口的分割来分离应用程序关心的概念。<br>事实上，这个例子一个更好的设计应该是这样的，如图：<br>小结<br>Single Responsibility Principle (SRP)从职责（改变理由）的侧面上为我们对类（接口）的抽象的颗粒度建立了判断基准：在为系统设计类（接口）的时候应该保证它们的单一职责性。</p><blockquote><ol><li>The Open-Closed Principle (OCP) - 开闭原则</li></ol></blockquote><p>开闭原则（OCP：Open-Closed Principle）是指在进行面向对象设计（OOD：Object Oriented Design）中，设计类或其他程序单位时，应该遵循：</p><ul><li>对扩展开放（open）</li><li>对修改关闭（closed）</li></ul><p>开闭原则是判断面向对象设计是否正确的最基本的原理之一。 根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。<br>A  扩展开放：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。<br> B 修改关闭：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求是修改关闭的。</p><p>这也是系统设计需要遵循开闭原则的原因：<br>1）稳定性。开闭原则要求扩展功能不修改原来的代码，这可以让软件系统在变化中保持稳定。<br>2）扩展性。开闭原则要求对扩展开放，通过扩展提供新的或改变原有的功能，让软件系统具有灵活的可扩展性。<br>遵循开闭原则的系统设计，可以让软件系统可复用，并且易于维护。</p><p>开闭原则的实现方法<br>为了满足开闭原则的 对修改关闭（closed for modification） 原则以及扩展开放（open for extension） 原则，应该对软件系统中的不变的部分加以抽象，在面向对象的设计中，<br>A 可以把这些不变的部分加以抽象成不变的接口，这些不变的接口可以应对未来的扩展；<br>B 接口的最小功能设计原则。根据这个原则，原有的接口要么可以应对未来的扩展；不足的部分可以通过定义新的接口来实现；<br>C 模块之间的调用通过抽象接口进行，这样即使实现层发生变化，也无需修改调用方的代码。</p><p>接口可以被复用，但接口的实现却不一定能被复用。接口是稳定的，关闭的，但接口的实现是可变的，开放的。可以通过对接口的不同实现以及类的继承行为等为系统增加新的或改变系统原来的功能，实现软件系统的柔软扩展。</p><pre><code>简单地说，软件系统是否有良好的接口（抽象）设计是判断软件系统是否满足开闭原则的一种重要的判断基准。现在多把开闭原则等同于面向接口的软件设计。</code></pre><p>开闭原则的相对性<br>软件系统的构建是一个需要不断重构的过程，在这个过程中，模块的功能抽象，模块与模块间的关系，都不会从一开始就非常清晰明了，所以构建100%满足开闭原则的软件系统是相当困难的，这就是开闭原则的相对性。但在设计过程中，通过对模块功能的抽象（接口定义），模块之间的关系的抽象（通过接口调用），抽象与实现的分离（面向接口的程序设计）等，可以尽量接近满足开闭原则。</p><blockquote><ol><li>Release Reuse Equivalency Principle (REP) - 重用发布等价原则</li></ol></blockquote><p>包的内部关系方面（聚合性）的原则，重用粒度等价于发布粒度。重用主要是从用户的观点来看的。对用户来说，使用某个发布单位（组件，类，类群等），如果作者因为某种原因对其作了修改而发布了一个新的版本，用户会期望在升级为新版本之后，不会影响到原系统的正常运作。<br>也就是说，对于一个可重用（能供其它用户或系统使用）的元素（组件，类，类群等），作者应该承诺新版本能够兼容旧版本。否则，用户将拒绝使用该元素。</p><blockquote><p>Robert C. Martin给出的对重用的定义：</p></blockquote><p>代码可以看作为可重用的代码，当且仅当：</p><ul><li>它的使用者（下称用户）无需看它的源代码</li><li>用户只需联结静态库或包含动态库</li><li>当库发生改变（错误纠正，功能增强）时，用户只需要得到一个新的版本便能集成到原有的系统</li></ul><p>怎么做到重用呢？<br>一个组件要做到能够重用，它必须有一个得到良好设计的结构，它所包含所有元素必须也是可以重用的。<br>因为如果一个为重用而设计的发布单位里，包含了不可重用的元素，当不可重用的元素发生改变时，用户也不得不改变原有系统以适应新的版本。这显然违反了重用的定义规则。<br>也就是说，一个为重用目的而设计的发布单位里，不能包含不可重用的元素；如果包含了不可重用的元素，它将变得不可重用。</p><p>发布单位<br>当用户使用的重用组件被作者修改后，用户希望得到通知，然后决定是否升级或升级的时机。为了能使升级后的系统也能正常运作，用户也希望作者有一个规范的发布，包括版本号，类库的说明等等。<br>一旦用户决定升级新版本，不管这些修改是否影响到用户，用户也不得不包含新版本所包含的所有类库。</p><p>REP规定重用粒度不能小于发布粒度，所有重用元素也必须被一起发布。</p><p>发布粒度可以为包（组件）或类等实体，但一个应用往往包含了很多类，所以，具有更大的尺度的包（组件）更加适合作为发布粒度。</p><p>重用发布等价原则为我们指明了包的设计方针：一个包中的元素（类）要么都可重用，要么都不可重用。</p><p>小结<br>重用发布等价原则（REP）从用户观点的角度上为我们规范了包设计的原则：在设计包时，包中应该包含的元素要么都可以重用，要么都不可以重用。</p><blockquote><ol><li>The Acyclic Dependencies Principle (ADP) - 无环依赖原则</li></ol></blockquote><p>包之间的依赖结构必须是一个直接的无环图形（DAG）。也就是说，在依赖结构中不允许出现环（循环依赖）。换成另一个说法是： 包间依赖不能是一个环状形式。包间关系方面（耦合性）的原则</p><p>包的依赖<br>如果一个包A 中的类引用了包B中的类，我们称包A依赖包B。<br>“依赖”在具体的程序语言中表现为，如果A依赖B，C/C++语言则在A包的文件/类中通过#include语句包含B包中的文件/类；Java语言则A包的类中通过import语句引入B包中的类。</p><p>图1（包A依赖包B）<br>虚线表示一种依赖关系，箭头表示依赖的方向，箭头所在的一侧就是被依赖的包。</p><p>包的循环依赖<br>我们上面讨论了并用图形表示了包之间的依赖关系。如果存在2个或2个以上的包，它们之间的依赖关系图出现了环状，我们就称包之间存在循环依赖关系。<br>也就是说它们的依赖结构图根据箭头的方向形成了一个环状的闭合图形。如图：<br>图2：包的循环依赖<br>如图：A依赖B，B依赖C，C依赖A，形成了一个环状依赖。<br>包的非循环依赖原则<br>包是一个比较合适的发布粒度，当修改了包中的代码（类，模块等）并发布新的版本时，我们需要把该包以及它所依赖的其它包一起发布。发布之后，还需要验证系统是否能在新发布的版本下正常运作。<br>如果多个包之间形成了循环依赖，比如如图2，A依赖B，B依赖C，C依赖A，我们修改了B并需要发布B的一个新的版本，因为B依赖C，所以发布时应该包含C，但C同时又依赖A，所以又应该把A也包含进发布版本里。也就是说，依赖结构中，出现在环内的所有包都不得不一起发布。它们形成了一个高耦合体，当项目的规模大到一定程度，包的数目变多时，包与包之间的关系便变得错综复杂，各种测试也将变得非常困难，常常会因为某个不相关的包中的错误而使得测试无法继续。而发布也变得复杂，需要把所有的包一起发布，无疑增加了发布后的验证难度。</p><p>循环依赖的打破方法<br>如果包的依赖形成了环状结构，怎么样打破这种循环依赖呢？<br>有2种方法可以打破这种循环依赖关系：第一种方法是创建新的包，第二种方法是使用DIP（依赖倒置原则）和ISP（接口分隔原则）设计原则。</p><p>方法一：创建新的包<br>比如对于图2这种依赖结构：</p><p>图2：包的循环依赖</p><p>包C要依赖包A，必定A中包含有A，C共通使用的类，把这些共同类抽出来放在一个新的包D里。这样就把C依赖A变成了C依赖D以及A依赖D，从而打破了循环依赖关系。如图：</p><p>这样，包的依赖关系就从A-&gt;B-&gt;C-&gt;A变成了：<br>A-&gt;B-&gt;C-&gt;D<br>A-&gt;D</p><p>方法二：DIP与ISP设计原则<br>ISP（接口分隔原则）可以剔除美用到的接口。DIP（依赖倒置原则）在类的调用之间引入抽象层。</p><p>如图,，包A依赖包B（因为包A中的类U使用了包B中的类X）；反过来，包B又依赖包A（因为包B中的类Y使用了包A中的类V）</p><p>包A，包B之间就形成了一种循环依赖。</p><p>我们使用DIP设计原则为V抽象一个接口IVforY，并把该接口放在B包中。<br>这样就把Y对V的调用转化为：<br>V继承IVforY<br>Y调用IVforY<br>如图：</p><p>这样一来，包B中的类就不依赖任何包A中的类了。<br>小结<br>无环依赖原则（ADP）为我们解决包之间的关系耦合问题。在设计包结构时，不能有循环依赖。</p><blockquote><ol><li>The Stable Dependencies Principle (SDP) - 稳定依赖原则</li></ol></blockquote><p>一个设计中的包之间的依赖应该朝着稳定的方向进行。一个包只应该依赖那些比自己更稳定的包。换成另一个说法是： 朝着稳定的方向进行依赖。包之间的关系方面（耦合性）的原则。</p><p>包的依赖<br>如果一个包A 中的类引用了包B中的类，我们称包A依赖包B。<br>“依赖”在具体的程序语言中表现为，如果A依赖B，C/C++语言则在A包的文件/类中通过#include语句包含B包中的文件/类；Java语言则A包的类中通过import语句引入B包中的类。<br>图1（包A依赖包B）<br>虚线表示一种依赖关系，箭头表示依赖的方向，箭头所在的一侧就是被依赖的包。</p><p>包的稳定依赖原则<br>包应该依赖比自己更稳定的包。因为如果依赖一个不稳定的包，那么当这个不稳定的包发生变化时，本身稳定的包也不得不发生变化，变得不稳定了。</p><p>所谓稳定，在现实生活中是指一个物体具有稳固不变的属性使它很难发生变化。应用到软件概念上，我们认为一个软件是稳定的，是因为这个软件很难发生改变，或更确切地说，是不需要发生改变。一个设计良好，能应对各种变化不需要修改的软件当然是稳定的了，但事实上，往往一个软件常常需要对应某个事先没有预测到的用户需求而不得不发生改变，当这种改变发生时，能把修改控制在最小的范围之内，并能稳定的工作（包括软件本身以及依赖它的其它软件实体等），我们也会认为该软件是相对稳定的。</p><p>怎么样让一个软件足够稳定呢？一个确切的方法是，让大量其它软件的包依赖它。一个包被很多其他包依赖是非常稳定的，这是因为被依赖的包为了协调其他包必须做很多的工作来对应各种变化（责任的负担者）。<br>图1：稳定的包X<br>我们认为X是稳定的，因为：</p><ul><li>X被很多其他包依赖。相当于责任担当着。</li><li>X没有依赖别的包，它是独立的。</li></ul><p>相反，下面列出了一个非常不稳定的包Y，如图：</p><p>图2：不稳定的包Y<br>我们认为Y是不稳定的，因为：</p><ul><li>Y没有被其他的包所依赖。不是责任的担当着。</li><li>Y依赖很多别的包。<br>包的稳定性的判断原则<br>可以通过下面的方法来判断一个包的稳定系数：<br>Ca：Afferent Coupling。向心耦合。依赖该包（包含的类）的外部包（类）的数目（i.e. incoming dependencies）。<br>Ce： Efferent Coupling。离心耦合。被该包依赖的外部包的数目（i.e. outgoing dependencies）。<br>I： Instability。不稳定性。I=Ce/(Ce+Ca)。它的值处于[0，1]之间。<br>如图1，X的Ce=0，所以不稳定性I=0，它是稳定的。相反，如图2，Y的Ce=3，Ca=0，所以它的不稳定性I=1，它是不稳定的。</li></ul><p>SDP要求一个包的不稳定性I要大于它所依赖的包的不稳定性。换句话说，沿着依赖的方向，包的不稳定性应该逐渐降低，稳定性应该逐渐升高。</p><p>稳定依赖原则（SDP）为我们解决包之间的关系耦合问题。在设计包结构时，包应该只依赖比自己更稳定的包。</p><blockquote><ol><li>The Stable AbstractionsPrinciple (SAP) - 稳定抽象等价原则</li></ol></blockquote><p>最稳定的包应该是最抽象的包。不稳定的包应该是具体的包。包的抽象程度跟它的稳定性成正比。稳定的包应该是抽象的包。</p><p>包的稳定抽象等价原则</p><p>我们在The Stable Dependencies Principle (SDP) - OO设计的稳定依赖原则 一文中谈到了包的稳定性：不容易改变的包应该具有更好的稳定性。</p><p>一个包的抽象程度越高，它的稳定性就越高。反之，它的稳定性就越低。一个稳定的包必须是抽象的，反之，不稳定的包必须是具体的。<br>稳定的包的构成<br>抽象类或接口通过子类继承扩展行为，这表示抽象类或接口比它们的子类更具有稳定性。总之，为了构成稳定的包，应该提高包内的抽象类或接口的比率；它们的子类可以放在另一个不稳定的包内，该包依赖上述稳定的包，从而遵循了稳定依赖原则（SDP）。</p><p>理想的体系结构应该是：<br>不稳定的（容易改变的）包处于上层</p><ul><li>它们是具体的包实现<br>稳定的（不容易改变的）包处于下层</li><li>不容易改变，但容易扩展</li><li>接口比实现（具体的运行代码）在内在特性上更具有稳定性<br>图1：遵循稳定依赖原则（SDP）的理想的体系结构</li></ul><p>小结<br>稳定抽象等价原则（SAP）为我们解决包之间的关系耦合问题。在设计包结构时，稳定的包应该是抽象的（由抽象类或接口构成），不稳定的包应该是具体的（由具体的实现类构成）。</p><blockquote><ol><li>The Common ClosurePrinciple (CCP) - 共同封闭原则</li></ol></blockquote><p>一个包中所有的类应该对同一种类型的变化关闭。一个变化影响一个包，便影响了包中所有的类。一个更简短的说法是：一起修改的类，应该组合在一起（同一个包里）。包的内部关系方面（聚合性）的原则</p><p>如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。<br>CCP原则就是把因为某个同样的原因而需要修改的所有类组合进一个包里。如果2个类从物理上或者从概念上联系得非常紧密，它们通常一起发生改变，那么它们应该属于同一个包。</p><p>CCP跟开闭原则（OCP: Open Closed Principle） 有着很深的渊源关系，CCP的“关闭”（closure）就是OCP所提倡的：classes should be closed for modification but open for extension. 类应该对修改关闭，对扩展开放。但我们知道，100%的“关闭”是不现实的，我们在设计系统时，只能尽量地保持对大多数可预见的修改关闭。<br>CCP延伸了OCP的“关闭”概念，当因为某个原因需要修改时，把需要修改的范围限制在一个最小范围内的包里。CCP原则帮助我们决定哪些类应该被放到同一个包里。</p><p>小结<br>共同封闭原则（CCP）从软件功能的角度上为我们规范了包设计的一个原则：在设计包时，相互之间紧密关联的类应该放在同一包里。</p><blockquote><ol><li>The Common Reuse Principle (CRP) - 全部重用原则</li></ol></blockquote><p>包的所有类被一起重用。如果你重用了其中的一个类，就重用全部。换成另一个比较浅显易懂的说法：没有被一起重用的类不应该被组合在一起。CRP原则帮助我们决定哪些类应该被放到同一个包里。包的内部关系方面（聚合性）的原则</p><p>依赖一个包就是依赖这个包所包含的一切。当一个包发生了改变，并发布新的版本，使用这个包的所有用户都必须在新的包环境下验证他们的工作，即使被他们使用的部分没有发生任何改变。<br>因为如果包中包含有未被使用的类，即使用户不关心该类是否改变，但用户还是不得不升级该包并对原来的功能加以重新测试。</p><p>“不能强迫用户去依赖那些他们不使用的接口”，把这个概念应用到更广范围的包上，就是CRP的基本理念：不要把用户不使用的类一起组合进包里。</p><p>CRP与REP一样，都是从方便用户重用的角度去设计包，重用者是他们的受益者，CCP则让系统的维护者受益。CCP让包尽可能大（CCP原则加入功能相关的类），CRP则让包尽可能小（CRP原则剔除不使用的类）。它们的出发点不一样，但不相互冲突。CRP保证了包的内部具有很高的聚合性。</p><p>全部重用原则（CRP）从用户的角度上为我们规范了包设计的一个原则：在设计包时，相互之间没有紧密关联的类不应该放在同一包里。</p><blockquote><ol><li>Least Knowledge Principle (LKP) -迪米特法则</li></ol></blockquote><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP）。<br>一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的public方法，我就调用这么多，其他的一概不关心。</p><p>含义：<br>只和朋友交流<br>朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。下面的代码在方法体内部依赖了其他类，这严重违反迪米特法则</p><pre><code>public class Teacher {    public void commond(GroupLeader groupLeader) {        List&lt;Girl&gt; listGirls = new ArrayList&lt;Girl&gt;();        for (int i = 0; i &lt; 20; i++) {            listGirls.add(new Girl());        }        groupLeader.countGirls(listGirls);    }}</code></pre><p>方法是类的一个行为，类竟然不知道自己的行为与其他类产生了依赖关系，这是不允许的。<br>正确的做法是：</p><pre><code>public class Teacher {    public void commond(GroupLeader groupLeader) {        groupLeader.countGirls();    }}public class GroupLeader {    private List&lt;Girl&gt; listGirls;    public GroupLeader(List&lt;Girl&gt; _listGirls) {        this.listGirls = _listGirls;    }    public void countGirls() {        System.out.println(&quot;女生数量是：&quot; + listGirls.size());    }}</code></pre><p>注意：一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况（在一种极端情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK API提供的类除外。<br>朋友间也是有距离的<br>一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前不加访问权限，则默认为包类型）、protected等访问权限，是否可以加上final关键字等。<br>注意：迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。</p><p>是自己的就是自己的<br>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，就放置在本类中。</p><p>谨慎使用Serializable</p><p>最后，迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。</p><blockquote><p>  Principle –纵览</p></blockquote><pre><code>----类原则 ----</code></pre><p>1.单一职责原则 -Single Responsibility Principle(SRP)<br>就一个类而言，应该仅有一个引起它变化的原因。<br>(职责即为“变化的原因”。)<br>2.开放-封闭原则 - OpenClose Principle(OCP)<br>软件实体（类、模块、函数等）应该是可以扩展的，但是不可修改。<br>(对于扩展是开放的,对于更改是封闭的.<br>关键是抽象.将一个功能的通用部分和实现细节部分清晰的分离开来.<br>开发人员应该仅仅对程序中呈现出频繁变化的那些部分作出抽象.<br>拒绝不成熟的抽象和抽象本身一样重要. )<br>3.里氏替换原则 -Liskov Substitution Principle(LSP)<br>子类型(subclass)必须能够替换掉它们的基类型(superclass)。<br>4.依赖倒置原则(IoCP) 或 依赖注入原则 -Dependence Inversion Principle(DIP)<br>抽象不应该依赖于细节。细节应该依赖于抽象。<br>(Hollywood原则: “Don’t call us, we’ll call you”.<br>程序中所有的依赖关系都应该终止于抽象类和接口。<br>针对接口而非实现编程。<br>任何变量都不应该持有一个指向具体类的指针或引用。<br>任何类都不应该从具体类派生。<br>任何方法都不应该覆写他的任何基类中的已经实现了的方法。)<br>5.接口隔离原则(ISP)<br>不应该强迫客户依赖于它们不用的方法。<br>接口属于客户，不属于它所在的类层次结构。<br>(多个面向特定用户的接口胜于一个通用接口。)</p><blockquote><p>—-包内聚原则 —-</p></blockquote><p>6.重用发布等价原则(REP)<br>重用的粒度就是发布的粒度。<br>7.共同封闭原则(CCP)<br>包中的所有类对于同一类性质的变化应该是共同封闭的。<br>一个变化若对一个包产生影响，<br>则将对该包中的所有类产生影响，<br>而对于其他的包不造成任何影响。<br>8.共同重用原则(CRP)<br>一个包中的所有类应该是共同重用的。<br>如果重用了包中的一个类，<br>那么就要重用包中的所有类。<br>(相互之间没有紧密联系的类不应该在同一个包中。)<br>—-包耦合原则<br>9.无环依赖原则(ADP)<br>在包的依赖关系图中不允许存在环。<br>10.稳定依赖原则(SDP)<br>朝着稳定的方向进行依赖。<br>应该把封装系统高层设计的软件（比如抽象类）放进稳定的包中，<br>不稳定的包中应该只包含那些很可能会改变的软件（比如具体类）。<br>11.稳定抽象原则(SAP)<br>包的抽象程度应该和其稳定程度一致。<br>(一个稳定的包应该也是抽象的，一个不稳定的包应该是抽象的. )</p><blockquote><p>—-其它扩展原则—-</p></blockquote><p>12.BBP(Black Box Principle)黑盒原则<br>多用类的聚合，少用类的继承。<br>13.DAP(Default Abstraction Principle)缺省抽象原则<br>在接口和实现接口的类之间引入一个抽象类,这个类实现了接口的大部分操作.<br>14.IDP(Interface Design Principle)接口设计原则<br>规划一个接口而不是实现一个接口。<br>15.DCSP(Don’t Concrete Supperclass Principle)不要构造具体的超类原则<br>避免维护具体的超类。<br>16.迪米特法则<br>一个类只依赖其触手可得的类。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>resume2</title>
      <link href="/2015/06/09/resume2/"/>
      <content type="html"><![CDATA[<p>姓名<br>170 7777 7777 | xxx@gmail.com | github.com/xx | www.xx.com</p><p><strong>个人经历</strong><br>20xx/xx—至今<br>codeKK2 公司 | Android 资深开发<br>工作描述：带领移动团队负责 xx，取得了什么成绩</p><p>20xx/xx—20xx/xx<br>codeKK1 公司 | Android 高级开发<br>工作描述：负责 xx 产品，取得了什么成绩</p><p>20xx/xx—20xx/xx<br>XXX 学校 | XX 专业 | 本科<br>专业排名：x/xxx        GPA：</p><p><strong>专业技能</strong><br>x 年团队管理经验，x 年开发经验，x 年移动开发经验<br>开源 xx 项目，用于 xx，多少 Star，多少 Contributors<br>博客主要分享 xx xx<br>熟悉 Android 应用框架设计，熟悉 Android 高性能编程及调优<br>熟悉xx 技术点，xx 技术点，xx 技术点</p><p><strong>项目经验</strong></p><ol><li><p>20xx/xx—至今 | codeKK2 公司 | XX 项目<br>项目简介：<br>职责：</p></li><li><p>20xx/xx—20xx/xx | codeKK2 公司 | XX 项目<br>项目简介：<br>职责：</p></li><li>20xx/xx—20xx/xx | codeKK2 公司 | XX 项目<br>项目简介：<br>职责：</li><li><p>20xx/xx—20xx/xx | codeKK1 公司 | XX 项目<br>项目简介：<br>职责：</p></li><li><p>20xx/xx—20xx/xx | codeKK1 公司 | XX 项目<br>项目简介：<br>职责：</p></li></ol><p><strong>在校经历</strong><br>XX大赛 XX 奖<br>XX 系统设计、开发<br>XXX 奖学金</p>]]></content>
      
      <categories>
          
          <category> resume </category>
          
      </categories>
      
      
        <tags>
            
            <tag> resume </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ANDROID SUPPORT兼容包详解</title>
      <link href="/2015/06/08/ANDROID%20SUPPORT%E5%85%BC%E5%AE%B9%E5%8C%85%E8%AF%A6%E8%A7%A3/"/>
      <content type="html"><![CDATA[<p> Support Library</p><p>我们都知道Android一些SDK比较分裂，为此google官方提供了Android Support Library package 系列的包来保证高版本sdk开发的向下兼容性, 所以你可能经常看到v4，v7，v13这些数字，首先我们就来理清楚这些数字的含义，以及它们之间的区别。</p><p>support-v4<br>用在API lever 4(即Android 1.6)或者更高版本之上。它包含了相对更多的内容，而且用的更为广泛，例如：Fragment，NotificationCompat，LoadBroadcastManager，ViewPager，PageTabStrip，Loader，FileProvider 等</p><p>Gradle引用方法：</p><p>compile ‘com.android.support:support-v4:21.0.3’</p><p>support-v7<br>这个包是为了考虑API level 7(即Android 2.1)及以上版本而设计的，但是v7是要依赖v4这个包的，v7支持了Action Bar以及一些Theme的兼容。</p><p>Gradle引用方法:</p><p>compile ‘com.android.support:appcompat-v7:21.0.3’<br>support-v13<br>这个包的设计是为了API level 13(即Android 3.2)及更高版本的，一般我们都不常用，平板开发中能用到，这里就不过多介绍了。</p><p>Theme</p><p>回到知乎上的这个问题，我们来介绍下各种Theme的概念。</p><p>Hoho Theme<br>在4.0之前Android可以说是没有设计可言的，在4.0之后推出了Android Design，从此Android在设计上有了很大的改善，而在程序实现上相应的就是Holo风格，所以你看到有类似 Theme.Holo.Light、 Theme.Holo.Light.DarkActionBar 就是4.0的设计风格，但是为了让4.0之前的版本也能有这种风格怎么办呢？这个时候就不得不引用v7包了，所以对应的就有 Theme.AppCompat.Light、 Theme.AppCompat.Light.DarkActionBar，如果你的程序最小支持的版本是4.0，那么可以不用考虑v7的兼容。</p><p>Material Design Theme<br>今年的5.0版本，Android推出了Material Design的概念，这是在设计上Android的又一大突破。对应的程序实现上就有 Theme.Material.Light、 Theme.Material.Light.DarkActionBar等，但是这种风格只能应用在在5.0版本的手机，如果在5.0之前应用Material Design该怎么办呢？同样的引用appcompat-v7包，这个时候的Theme.AppCompat.Light、 Theme.AppCompat.Light.DarkActionBar就是相对应兼容的Material Design的Theme。</p><p>注意事项</p><p>gradle引用appcompat-v7包的时候就不需要引用v4了，因为v7里默认包含了v4包；<br>compile ‘com.android.support:appcompat-v7:21.0.3’ 中的21代表API level 21推出的兼容包，所以如果你引用的是21之前的版本，则默认这些Theme.AppCompat.Light是Holo风格的，从21开始的版本默认是Material风格<br>使用appcompat之后，你的所有的Activity应该继承自ActionBarActivity，而ActionBarActivity继承自FragmentActivity，所以放心的使用Fragment；</p>]]></content>
      
      <categories>
          
          <category> resume </category>
          
      </categories>
      
      
        <tags>
            
            <tag> resume </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>resume1</title>
      <link href="/2015/06/08/resume1/"/>
      <content type="html"><![CDATA[<p>姓名<br>Phone：170 7777 7777　　　　　　　　  Email：xxx@gmail.com</p><p>GitHub：github.com/xx　　　　　　　　　Blog：www.xx.com</p><p><strong>个人经历</strong></p><pre><code>■    20xx/xx—至今                    codeKK2 公司                Android 资深开发</code></pre><p>带领移动团队负责 xx，取得了什么成绩</p><pre><code>■    20xx/xx—20xx/xx                codeKK1 公司                 Android 高级开发</code></pre><p>负责 xx 产品，取得了什么成绩</p><pre><code>■    20xx/xx—20xx/xx                XX 学校                    本科</code></pre><p><strong>xx 专业</strong><br><strong>专业排名：x/xxx                GPA：</strong></p><p><strong>专业技能</strong></p><ul><li>x 年团队管理经验，x 年开发经验，x 年移动开发经验</li><li>开源 xx 项目，用于 xx，多少 Star，多少 Contributors</li><li>博客主要分享 xx xx</li><li>熟悉 Android 应用框架设计，熟悉 Android 高性能编程及调优</li><li>熟悉 xx 技术点，xx 技术点，xx 技术点</li></ul><p><strong>项目经历</strong></p><pre><code>■    20xx/xx—至今                XX 项目                        codeKK2 公司</code></pre><p><strong>项目简介：</strong><br><strong>职责：</strong></p><pre><code>■    20xx/xx—20xx/xx             XX 项目                        codeKK2 公司</code></pre><p><strong>项目简介：</strong><br><strong>职责：</strong></p><pre><code>■    20xx/xx—20xx/xx             XX 项目                        codeKK2 公司</code></pre><p><strong>项目简介：</strong><br><strong>职责：</strong></p><pre><code>■    20xx/xx—20xx/xx                 XX 项目                        codeKK1 公司</code></pre><p><strong>项目简介：</strong><br><strong>职责：</strong></p><pre><code>■    20xx/xx—20xx/xx                 XX 项目                        codeKK1 公司</code></pre><p><strong>项目简介：<br>职责</strong>：</p><p><strong>在校经历</strong><br>●    XX 比赛 XX 奖<br>●    XX 系统设计、开发<br>●    XXX 奖学金<br>各大互联网公司 Android 内推到 <a href="http://j.codekk.com/" target="_blank" rel="noopener">http://j.codekk.com/</a></p>]]></content>
      
      <categories>
          
          <category> resume </category>
          
      </categories>
      
      
        <tags>
            
            <tag> resume </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>service详解</title>
      <link href="/2015/01/18/service%E8%AF%A6%E8%A7%A3/"/>
      <content type="html"><![CDATA[<blockquote><p><strong>android server 详解</strong></p><p> Service的种类：</p><p>一、Service的种类</p></blockquote><ol><li>本地服务， Local Service<br>用于应用程序内部。在Service可以调用Context.startService()启动，调用Context.stopService()结束。在内部可以调用Service.stopSelf()<br>或<br>Service.stopSelfResult()来自己停止。无论调用了多少次startService()，都只需调用一次stopService()来停止。</li><li>远程服务， Remote Service<br>用于android系统内部的应用程序之间。可以定义接口并把接口暴露出来，以便其他应用进行操作。客户端建立到服务对象的连接，并通过那个连接来调用服务。调用Context.bindService()方法建立连接，并启动，以调用<br>Context.unbindService()关闭连接。多个客户端可以绑定至同一个服务。如果服务此时还没有加载，bindService()会先加载它。</li></ol><p>提供给可被其他应用复用，比如定义一个天气预报服务，提供与其他应用调用即可。</p><blockquote><p> 二、生命周期</p></blockquote><p>1). 被启动的服务的生命周期：如果一个Service被某个Activity 调用 Context.startService方法启动，那么不管是否有Activity使用bindService绑定或unbindService解除绑定到该Service，该Service都在后台运行。如果一个Service被startService 方法多次启动，那么onCreate方法只会调用一次，onStart将会被调用多次（对应调用startService的次数），并且系统只会创建Service的一个实例（因此你应该知道只需要一次stopService调用）。该Service将会一直在后台运行，而不管对应程序的Activity是否在运行，直到被调用stopService，或自身的stopSelf方法。当然如果系统资源不足，android系统也可能结束服务。</p><p>2). 被绑定的服务的生命周期：如果一个Service被某个Activity 调用 Context.bindService 方法绑定启动，不管调用 bindService调用几次，onCreate方法都只会调用一次，同时onStart方法始终不会被调用。当连接建立之后，Service将会一直运行，除非调用Context.unbindService 断开连接或者之前调用bindService 的 Context 不存在了（如Activity被finish的时候），系统将会自动停止Service，对应onDestroy将被调用。</p><p>3).被启动又被绑定的服务的生命周期：如果一个Service又被启动又被绑定，则该Service将会一直在后台运行。并且不管如何调用，onCreate始终只会调用一次，对应startService调用多少次，Service的onStart便会调用多少次。调用unbindService将不会停止Service，而必须调用 stopService 或 Service的 stopSelf 来停止服务。</p><p>4).当服务被停止时清除服务：当一个Service被终止（1、调用stopService；2、调用stopSelf；3、不再有绑定的连接（没有被启动））时，onDestroy方法将会被调用，在这里你应当做一些清除工作，如停止在Service中创建并运行的线程。</p><blockquote><p>特别注意：</p></blockquote><ol><li><p>你应当知道在调用 bindService 绑定到Service的时候，你就应当保证在某处调用 unbindService<br>解除绑定（尽管Activity被finish的时候绑定会自动解除，并且Service会自动停止）</p></li><li><p>你应当注意 使用 startService 启动服务之后，一定要使用<br>stopService停止服务，不管你是否使用bindService。</p></li><li><p>同时使用 startService 与 bindService 要注意到，Service<br>的终止，需要unbindService与stopService同时调用，才能终止 Service，不管 startService 与<br>bindService 的调用顺序，如果先调用 unbindService 此时服务不会自动终止，再调用 stopService<br>之后服务才会停止，如果先调用 stopService 此时服务也不会终止，而再调用 unbindService 或者 之前调用<br>bindService 的 Context 不存在了（如Activity 被 finish 的时候）之后服务才会自动停止。</p></li><li><p>当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity<br>的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了），对应服务的生命周期与上述相同</p></li><li><p>在 sdk 2.0 及其以后的版本中，对应的 onStart 已经被否决变为了 onStartCommand，不过之前的 onStart<br>任然有效。这意味着，如果你开发的应用程序用的 sdk 为 2.0 及其以后的版本，那么你应当使用 onStartCommand 而不是<br>onStart。<br><img src="http://static.oschina.net/uploads/space/2015/0730/095222_Jssm_1175007.png" alt="此处输入图片的描述"></p></li></ol><blockquote><p>例子：</p></blockquote><pre><code>    public class ServiceDemo extends Service {    public static final String TAG = &quot;ServiceDemo&quot; ;    public static final String ACTION = &quot;com.demo.SERVICE_DEMO&quot;;    /**     * onBind 是 Service 的虚方法，因此我们不得不实现它。     * 返回 null，表示客服端不能建立到此服务的连接，所以不会调用onServiceConnected。     */    @Override    public IBinder onBind(Intent intent) {        Log.i(TAG, this.toString() + &quot; ServiceDemo onBind&quot;);        return null;    }    @Override    public void onCreate() {        Log.i(TAG, this.toString() + &quot; ServiceDemo onCreate&quot;);        super.onCreate();    }    @Override    public void onStart(Intent intent, int startId) {    Log.i(TAG, this.toString() + &quot; ServiceDemo onStart&quot;);    super.onStart(intent, startId);    }    @Override    public int onStartCommand(Intent intent, int flags, int startId) {        Log.i(TAG, this.toString() + &quot; ServiceDemo onStartCommand&quot;);        return super.onStartCommand(intent, flags, startId);    }    @Override    public boolean onUnbind(Intent intent) {        Log.i(TAG, this.toString() + &quot; ServiceDemo onUnbind&quot;);        return super.onUnbind(intent);    }    @Override    public void onDestroy() {        Log.i(TAG, this.toString() + &quot; ServiceDemo onDestroy&quot;);        super.onDestroy();    }}&lt;!-- android:exported 这个属性用于指示该服务是否能够被其他应用程序组件调用或跟它交互。     如果设置为true，则能够被调用或交互，否则不能。设置为false时，     只有同一个应用程序的组件或带有相同用户ID的应用程序才能启动或绑定该服务。--&gt;&lt;service android:name=&quot;.ServiceDemo&quot; android:exported=&quot;false&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;com.demo.SERVICE_DEMO&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.default&quot; /&gt;    &lt;/intent-filter&gt;&lt;/service&gt;通过Context.startService(Intent)方法启动service或者Context.bindService方法来绑定service    public class MainActivity extends ActionBarActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        findViewById(R.id.btn_bindService).setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {            bindService(new Intent(ServiceDemo.ACTION), conn, BIND_AUTO_CREATE);        }    });        findViewById(R.id.btn_unbindService).setOnClickListener(new OnClickListener() {            @Override        public void onClick(View v) {        unbindService(conn);        }    });        findViewById(R.id.btn_startService).setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {            startService(new Intent(ServiceDemo.ACTION));            }        });        findViewById(R.id.btn_stopService).setOnClickListener(new OnClickListener() {        @Override        public void onClick(View v) {        stopService(new Intent(ServiceDemo.ACTION));        }    });    }    ServiceConnection conn = new ServiceConnection() {        public void onServiceConnected(ComponentName name, IBinder service) {            Log.i(ServiceDemo.TAG, service.toString() + &quot; onServiceConnected&quot;);        }    public void onServiceDisconnected(ComponentName name) {        Log.i(ServiceDemo.TAG, &quot;onServiceDisconnected&quot;);    }    };    @Override    protected void onDestroy() {        super.onDestroy();    }}</code></pre><p>  <img src="http://static.oschina.net/uploads/space/2015/0730/160834_rK7t_1175007.png" alt="此处输入图片的描述"></p><blockquote><p>日志输出：</p></blockquote><p><img src="http://static.oschina.net/uploads/space/2015/0730/160949_ye2r_1175007.png" alt="此处输入图片的描述"><br>上面的截图是点击绑定服务时输出的。可以看出，只调用了onCreate方法和onBind方法，当重复点击绑定服务时，没有再输出任何日志，并且不报错。onCreate方法是在第一次创建Service时调用的，而且只调用一次。另外，在绑定服务时，给定了参数BIND_AUTO_CREATE，即当服务不存在时，自动创建，如果服务已经启动了或者创建了，那么只会掉调用onBind方法。<br><img src="http://static.oschina.net/uploads/space/2015/0730/161109_fGYl_1175007.png" alt="此处输入图片的描述"><br>当解除绑定的时，可以看出，Service调用onUnbind和onDestroy销毁了服务。<br><img src="http://static.oschina.net/uploads/space/2015/0730/161604_zRTz_1175007.png" alt="此处输入图片的描述"><br>上面的截图是在多次点击启动服务时输出的。可以看出，在第一次点击时，因为Service还未创建，所以调用了onCreate方法，紧接着调用了onStartCommand和onStart方法。当再次点击启动服务时，仍然调用了onStartCommand和onStart方法，所以，在Service中做任务处理时需要注意这点，因为一个Service可以被重复启动。<br><img src="http://static.oschina.net/uploads/space/2015/0730/161711_V5xw_1175007.png" alt="此处输入图片的描述"><br>当点停止服务的时，Service只是执行onDestroy方法，跟绑定还是有点小区别。<br>这里说一下，平常使用多的是startService方法，可以把一些耗时的任务放到后台去处理，当处理完成后，可以通过广播来通知前台。<br>而onBind方法更多的是结合AIDL来使用，这样一个应用可以通过绑定服务获得的IBinder来拿到后台的接口，进而调用AIDL中定义的方法，进行数据交换等。</p><blockquote><p>三、Local 与 Remote 服务绑定</p></blockquote><p>1) Local 服务绑定：Local 服务的绑定较简单，首先在 Service 中我们需要实现 Service 的抽象方法 onBind，并返回一个实现 IBinder 接口的对象。</p><p>Service 中的代码：</p><pre><code>    public class LocalService extends Service{    public static final String TAG = &quot;LocalService&quot; ;    public static final String ACTION = &quot;com.demo.LOCAL_SERVICE&quot;;    public SimpleBinder sBinder;    public class SimpleBinder extends Binder{        public LocalService getService(){            return LocalService.this;        }        public int add(int a, int b){            return a + b;        }    }    @Override    public void onCreate() {    super.onCreate();    // 创建 SimpleBinder        sBinder = new SimpleBinder();    }    @Override    public IBinder onBind(Intent intent) {    // 返回 SimpleBinder 对象    Log.i(TAG, &quot;LocalService onBind&quot;);        return sBinder;    }    @Override    public boolean onUnbind(Intent intent) {    Log.i(TAG, &quot;LocalService onUnbind&quot;);    return super.onUnbind(intent);    }}&lt;service android:name=&quot;.LocalService&quot; android:exported=&quot;false&quot;&gt;    &lt;intent-filter&gt;    &lt;action android:name=&quot;com.demo.LOCAL_SERVICE&quot; /&gt;    &lt;category android:name=&quot;android.intent.category.default&quot; /&gt;    &lt;/intent-filter&gt;&lt;/service&gt;public class LocalActivity extends ActionBarActivity {    private ServiceConnection sc;    private boolean isBind;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);    setContentView(R.layout.activity_local);    sc = new ServiceConnection() {            @Override        public void onServiceConnected(ComponentName name, IBinder service) {            Log.i(LocalService.TAG, &quot;onServiceConnected&quot;);        LocalService.SimpleBinder sBinder = (LocalService.SimpleBinder)service;                Log.i(LocalService.TAG, &quot;3 + 5 = &quot; + sBinder.add(3, 5));        }            @Override            public void onServiceDisconnected(ComponentName name) {                Log.i(LocalService.TAG, &quot; onServiceDisconnected&quot;);            }        };        findViewById(R.id.btn_bindService).setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                bindService(new Intent(LocalService.ACTION), sc, Context.BIND_AUTO_CREATE);                isBind = true;            }        });        findViewById(R.id.btn_unbindService).setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                if(isBind){                    unbindService(sc);                    isBind = false;                }            }        });    }}</code></pre><p>在 Activity 中，我们通过 ServiceConnection 接口来取得建立连接 与 连接意外丢失的回调。bindService有三个参数，第一个是用于区分 Service 的Intent 与 startService 中的 Intent 一致，第二个是实现了 ServiceConnection 接口的对象，最后一个是 flag 标志位。有两个flag，BIND_DEBUG_UNBIND 与 BIND_AUTO_CREATE，前者用于调试（详细内容可以查看javadoc 上面描述的很清楚），后者默认使用。unbindService 解除绑定，参数则为之前创建的 ServiceConnection 接口对象。另外，多次调用 unbindService 来释放相同的连接会抛出异常，因此我创建了一个 boolean 变量来判断是否 unbindService 已经被调用过。</p><p>运行结果：<br><img src="http://static.oschina.net/uploads/space/2015/0730/173329_fLfe_1175007.png" alt="此处输入图片的描述"></p><p>在绑定服务的时候，需要一个服务连接对象，ServiceConnection，服务一旦连接，就会调用onServiceConnected方法，我们可以在这个方法里面返回我们的本地服务对象，具体看代码；而在服务断开时候会调用onServiceDisconnected方法，我们可以清理一些服务资源。</p><p>2) Remote 服务绑定：之前所谈的Service属于Local Service，即Service和Client在同一进程内（即同一application内），Service的生命周期服从进程的生命周期。在实际应用上，有时希望Service作为后台服务，不仅被同一进程内的activity使用，也可被其他进程所使用。</p><p>通常每个应用程序都在它自己的进程内运行，但有时需要在进程之间传递对象（IPC通信），你可以通过应用程序UI的方式写个运行在一个不同的进程中的service。在android平台中，一个进程通常不能访问其它进程中的内存区域。所以，他们需要把对象拆分成操作系统能理解的简单形式，以便伪装成对象跨越边界访问。编写这种伪装代码相当的枯燥乏味，好在android为我们提供了AIDL工具可以来做这件事。</p><p>AIDL(android接口描述语言)是一个IDL语言，它可以生成一段代码，可以使在一个android设备上运行的两个进程使用内部通信进程进行交互。如果你需要在一个进程中(例如在一个Activity中)访问另一个进程中(例如一个Service)某个对象的方法，你就可以使用AIDL来生成这样的代码来伪装传递各种参数。</p><p> <img src="http://static.oschina.net/uploads/space/2015/0802/170432_x9mE_1175007.png" alt="此处输入图片的描述"><br> Android提供AIDL（Android Interface Definition Language）工具帮助IPC之间接口的建立，大大地简化了开发者视图。通过下面的步骤实现client和service之间的通信：<br>1）定义AIDL接口 ，Eclipse将自动为Service建立接口IService<br>2）Client连接Service，连接到IService暴露给Client的Stub，获得stub对象；换句话，Service通过接口中的Stub向client提供服务，在IService中对抽象IService.Stub具体实现。<br>3）Client和Service连接后，Client可向使用本地方法那样，简单地直接调用IService.Stub里面的方法。<br>下面的例子给出client从提供定时计数的Remote Service，称为TestRemoteService，中获得服务的例子。</p><p><strong>步骤1：通过AIDL文件定义Service向client提供的接口，ITestRemoteService.aidl文件如下</strong></p><pre><code>interface ITestRemoteService {     int getCounter(); }我们在src的目录下添加一个ITestRemoteService.aidl文件，语法和java的相同。在这个例子中Service很简单，只提供计数器的值，故在接口中我们定义了int getCounter( )。</code></pre><p>AIDL文件很简单，Eclipse会根据文件自动生成相关的一个java interface文件，不过没有显示出来，如果直接使用命令行工具会帮助生成java文件。</p><p><strong>步骤2：Remote Service的编写，通过onBind()，在client连接时，传递stub对象。 TestRemoteService.java文件如下</strong>：</p><pre><code>//Service提供一个定时计数器，采用Runnable的方式实现。public class TestRemoteService extends Service{     private Handler serviceHandler = null;    private int counter = 0;     private TestCounterTask myTask = new TestCounterTask();      public void onCreate() {          super.onCreate();         showInfo(&quot;remote service onCreate()&quot;);    }      public void onDestroy() {         super.onDestroy();         serviceHandler.removeCallbacks(myTask); //停止计数器        serviceHandler = null;         showInfo(&quot;remote service onDestroy()&quot;);    }      public void onStart(Intent intent, int startId) {        // 开启计数器         super.onStart(intent, startId);         serviceHandler=new Handler();         serviceHandler.postDelayed(myTask, 1000);         showInfo(&quot;remote service onStart()&quot;);     }    //步骤2.1：具体实现接口中暴露给client的Stub，提供一个stub inner class来具体实现。     private ITestRemoteService.Stub stub= new ITestRemoteService.Stub() {       //步骤2.1：具体实现AIDL文件中接口的定义的各个方法。        public int getCounter() throws RemoteException {              showInfo(&quot;getCounter()&quot;);            return counter;         }     };  //步骤2.2：当client连接时，将触发onBind()，Service向client返回一个stub对象，//由此client可以通过stub对象来访问Service，本例中通过stub.getCounter()就可以获得计时器的当前计数。//在这个例子中，我们向所有的client传递同一stub对象。    public IBinder onBind(Intent arg0) {     //我们特别跟踪了stub对象的地址，可以在client连接service中看看通过ServiceConnection传递给client        showInfo(&quot;onBind() &quot; + stub);         return stub;    }    //用Runnable使用定时计数器，每10秒计数器加1。    private class TestCounterTask implements Runnable{        public void run() {              ++ counter;             serviceHandler.postDelayed(myTask,10000);             showInfo(&quot;running &quot; + counter);         }     }      //showInfo() 帮助我们进行信息跟踪，更好了解Service的运行情况    private void showInfo(String s){         System.out.println(&quot;[&quot; +getClass().getSimpleName()+&quot;@&quot; + Thread.currentThread().getName()+ &quot;] &quot; + s);    } }</code></pre><p><img src="http://static.oschina.net/uploads/space/2015/0802/171454_Lix4_1175007.png" alt="此处输入图片的描述"></p><p><strong>步骤3：Client和Service建立连接，获得stub，ServiceTest4.java代码如下</strong></p><pre><code>public class ServiceTest4 extends Activity{    //步骤3.1 定义接口变量     private ITestRemoteService remoteService = null;    private boolean isStarted = false;    //步骤3.1 定义连接变量，实现ServiceConnection接口    private CounterServiceConnection conn = null;    protected void onCreate(Bundle savedInstanceState) {        //5个button分别触发startService( )，stopService( ) ,        //bindService( ), releaseService( )和invokeService( )，        //下面两行，一行是显示从Service中获得的计数值，一行显示状态。        }     private void startService(){         Intent i = new Intent();        //我的这个包里面还有层次，如*.part1、*.part2,etc        i.setClassName(&quot;com.wei.android.learning&quot;, &quot;com.wei.android.learning.part5.TestRemoteService&quot;); //和之前的local service一样，通过intent开启Service，触发onCreate()[if Service没有开启]-&gt;onStart()        startService(i);         isStarted = true;          updateServiceStatus();      }     private void stopService(){         Intent i = new Intent();         i.setClassName(&quot;com.wei.android.learning&quot;,&quot;com.wei.android.learning.part5.TestRemoteService&quot;);        stopService(i); //触发Service的 onDestroy()[if Service存在]        isStarted = false;        updateServiceStatus();     }       //步骤3.3：bindService( )通过一个实现ServiceConnection接口的类于Service之间建立连接，   //注意到里面的参数Context.BIND_AUTO_CREATE，触发onCreate()[if Service不存在] –&gt; onBind().    private void bindService(){        if(conn == null){             conn = new CounterServiceConnection();            Intent i = new Intent();            i.setClassName(&quot;com.wei.android.learning&quot;,&quot;com.wei.android.learning.part5.TestRemoteService&quot;);           bindService(i, conn,Context.BIND_AUTO_CREATE);            updateServiceStatus();        }     }     private void releaseService(){         if(conn !=null){             unbindService(conn); //断开连接，解除绑定            conn = null;             updateServiceStatus();         }     }     private void invokeService(){          if(conn != null){             try{             //一旦client成功绑定到Service，就可以直接使用stub中的方法。                Integer counter =remoteService.getCounter();                 TextView t = (TextView)findViewById(R.id.st4_notApplicable);                t.setText(&quot;Counter value : &quot; + Integer.toString(counter));            }catch(RemoteException e){                 Log.e(getClass().getSimpleName(),e.toString());             }         }     }     //步骤3.2 class CounterServiceConnection实现ServiceConnection接口，    //需要具体实现里面两个触发onServiceConnected()和onServiceDisconnected()     private class CounterServiceConnection implements ServiceConnection{        @Override         public void onServiceConnected(ComponentName name, IBinder service) {            // 从连接中获得stub对象，根据我们的跟踪，remoteService就是service中的stub对象            remoteService = ITestRemoteService.Stub.asInterface(service);            showInfo(&quot;onServiceConnected()&quot; + remoteService);        }         @Override        public void onServiceDisconnected(ComponentName name) {             remoteService = null;            updateServiceStatus();             showInfo(&quot;onServiceDisconnected&quot;);        }     }     private void updateServiceStatus() {        TextView t = (TextView)findViewById( R.id.st4_serviceStatus);         t.setText( &quot;Service status: &quot;+(conn == null ? &quot;unbound&quot; : &quot;bound&quot;)+ &quot;,&quot;+ (isStarted ? &quot;started&quot; : &quot;not started&quot;; ));           }     private void showInfo(String s){        System.out.println(&quot;[&quot; +getClass().getSimpleName()+&quot;@&quot; + Thread.currentThread().getName()+ &quot;] &quot; + s);    }}</code></pre><p> <img src="http://static.oschina.net/uploads/space/2015/0802/171402_Rt1I_1175007.png" alt="此处输入图片的描述"></p><p> 注意：</p><p>Service.onBind如果返回null，则调用 bindService 会启动 Service，但不会连接上 Service，因此 ServiceConnection.onServiceConnected 不会被调用，但你任然需要使用 unbindService 函数断开它，这样 Service 才会停止。</p><p>其它：</p><p>1、在什么情况下使用 startService 或 bindService 或 同时使用startService 和 bindService</p><p>如果你只是想要启动一个后台服务长期进行某项任务那么使用 startService 便可以了。如果你想要与正在运行的 Service 取得联系，那么有两种方法，一种是使用 broadcast ，另外是使用 bindService ，前者的缺点是如果交流较为频繁，容易造成性能上的问题，并且 BroadcastReceiver 本身执行代码的时间是很短的（也许执行到一半，后面的代码便不会执行），而后者则没有这些问题，因此我们肯定选择使用 bindService（这个时候你便同时在使用 startService 和 bindService 了，这在 Activity 中更新 Service 的某些运行状态是相当有用的）。另外如果你的服务只是公开一个远程接口，供连接上的客服端（android 的 Service 是C/S架构）远程调用执行方法。这个时候你可以不让服务一开始就运行，而只用 bindService ，这样在第一次 bindService 的时候才会创建服务的实例运行它，这会节约很多系统资源，特别是如果你的服务是Remote Service，那么该效果会越明显（当然在 Service 创建的时候会花去一定时间，你应当注意到这点）。</p><p>2、在 AndroidManifest.xml 里 Service 元素的常见选项</p><p>android:name，服务类名</p><p>android:label，服务的名字，如果此项不设置，那么默认显示的服务名则为类名</p><p>android:icon，服务的图标</p><p>android:permission，申明此服务的权限，这意味着只有提供了该权限的应用才能控制或连接此服务</p><p>android:process，表示该服务是否运行在另外一个进程，如果设置了此项，那么将会在包名后面加上这段字符串表示另一进程的名字</p><p>android:enabled，如果此项设置为 true，那么 Service 将会默认被系统启动，不设置默认此项为 false</p><p>android:exported，表示该服务是否能够被其他应用程序所控制或连接，不设置默认此项为 false</p><p>3、Service 与 Thread 的区别</p><p>很多时候，你可能会问，为什么要用 Service，而不用 Thread 呢，因为用 Thread 是很方便的，比起 Service 也方便多了，下面我详细的来解释一下。</p><p>1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。</p><p>2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。因此请不要把 Service 理解成线程，它跟线程半毛钱的关系都没有！</p><p>既然这样，那么我们为什么要用 Service 呢？其实这跟 android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。</p><p>举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。</p><p>因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。</p><p>4、拥有service的进程具有较高的优先级</p><p>官方文档告诉我们，Android系统会尽量保持拥有service的进程运行，只要在该service已经被启动(start)或者客户端连接(bindService)到它。当内存不足时，需要保持，拥有service的进程具有较高的优先级。</p><p>1). 如果service正在调用onCreate,onStartCommand或者onDestory方法，那么用于当前service的进程则变为前台进程以避免被killed。</p><p>2). 如果当前service已经被启动(start)，拥有它的进程则比那些用户可见的进程优先级低一些，但是比那些不可见的进程更重要，这就意味着service一般不会被killed.</p><p>3). 如果客户端已经连接到service (bindService),那么拥有Service的进程则拥有最高的优先级，可以认为service是可见的。</p><p>4). 如果service可以使用startForeground(int, Notification)方法来将service设置为前台状态，那么系统就认为是对用户可见的，并不会在内存不足时killed。</p><p>如果有其他的应用组件作为Service,Activity等运行在相同的进程中，那么将会增加该进程的重要性。</p><p>5、注意事项</p><p>Service的onCreate的方法只会被调用一次，就是你无论多少次的startService又 bindService，Service只被创建一次。如果先是bind了，那么start的时候就直接运行Service的onStart方法，如果先是start，那么bind的时候就直接运行onBind方法。如果你先bind上了，就stop不掉了，只能先UnbindService, 再StopService,所以是先start还是先bind行为是有区别的。 </p><p>Android中的服务和windows中的服务是类似的东西，服务一般没有用户操作界面，它运行于系统中不容易被用户发觉，可以使用它开发如监控之类的 程序。</p><p>服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。</p><p>这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同 时生，必须同时死”的特点。</p><p>如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次 创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结 束服务，服务结束时会调用onDestroy()方法。</p><p>如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。</p><p>如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的 onUnbind()–&gt;onDestroy()方法.   </p><p>原文地址：<a href="http://aswang.iteye.com/blog/1424309" target="_blank" rel="noopener">http://aswang.iteye.com/blog/1424309</a></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> service </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>View的技术传递</title>
      <link href="/2014/12/08/View%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BC%A0%E9%80%92/"/>
      <content type="html"><![CDATA[<p> <strong>1. 基础知识</strong><br>     (1)  所有Touch事件都被封装成MotionEvent对象，包括Touch的位置、时间、历史记录以及第几个手指(多手指触摸灯)。<br>    (2)  事件类型分类为ACTION_DOWN，ACTION_UP，ACTION_MOVE，ACTION_POINTER_DOWN，ACTION_POINTER_UP，ACTION_CANCEL，每个事件都以ACTION_DOWN开始ACTION_UP结束。<br>    (3)  对事件的处理包括三类，分别为传递—dispatchTouchEvent()函数、拦截—oninterceptTouchEvent函数、消费—-onTouchEvent函数和OnTouchListener<br><strong>2.传递流程</strong><br>    (1)  事件从Activity.dispatchTouchEvent开始传递,只要没有被停止或拦截,从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过OnTouchEvent()对事件进行处理。<br>    (2)  事件由父View(ViewGroup)传递给子View,ViewGroup可以通过oniterceptTouchEvent对事件做拦截,停止其往下传递。<br>    (3)  如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(Group)可以进行消费，如果还是没有被消费的话，最后会到Activity的OnTouchEven()函数。<br>    (4)如果View没有对ACTION_DOUWN进行消费,之后的其他事件不会传递过来<br>    (5)  OnTouchListener优于OnTouchEvent()对事件进行消费。<br>    上面的消费即表示相应函数返回值为true<br>    (1)View不处理事件流程图<br>    <img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tech/touch-event/image/ignorant-view-example.jpg" alt="此处输入图片的描述"><br>    (2)View处理事件流程图<br>    <img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tech/touch-event/image/interested-view-example.jpg" alt="此处输入图片的描述"></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> view </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>view自定义入门基础</title>
      <link href="/2014/12/08/view%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"/>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> view </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读不透的言辞</title>
      <link href="/2014/10/01/%E8%AF%BB%E4%B8%8D%E9%80%8F%E7%9A%84%E8%A8%80%E8%BE%9E/"/>
      <content type="html"><![CDATA[<blockquote><p>没什么比懂自己的心来得更重要. </p></blockquote>]]></content>
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo插入本地图片</title>
      <link href="/2014/09/22/hexo%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"/>
      <content type="html"><![CDATA[<p>1.先把hexo[你的项目]目录下的配置文件[_config.yml ]打开，更改里面的 post_asset_folder：true。<br>2.在dos命令行下，操作到你的hexo[你的项目]目录下，输入 npm install hexo-asset-image –save 命令，这是下载安装一个可以上传本地图片的插件。<br>3.稍等片刻，在dos命令行下，输入hexo n “xxx”来生成md博客文件后，在hexo[你的项目]目录下source/_posts文件夹里，会生成刚才输入命令的 “xxx”.md文件和”xxx”文件夹<br>4.编辑打开”xxx”.md文件，然后在”xxx”.md文件中按照markdown的格式引入图片： <img src="/2014/09/22/hexo插入本地图片/图片名.png" alt="你想输入的替代文字"> 或者 <img src="/2014/09/22/hexo插入本地图片/图片名.png">在”xxx”文件夹存放图片即可<br>5.另种方式：在hexo[你的项目]目录下source文件夹，新建images文件夹存放图片，引用方式如下两种<br><img src="/2014/09/22/hexo插入本地图片/../../../../images/20180426104055.png" alt="Alt text"><br>&lt;img src=”../../../../images/20180426104055.png &gt;<br>6.因为 hexo g生成网页后，会在hexo[你的项目]下生成public/xx/xx/xx/文件名/index.html 所以前xx/xx/xx/文件名/ 就像相当于 ../../../../这是在hexo目录下source文件夹，新建images管理图片的好处。</p><p>第一种方式就是对应的每个xx.md文件生成一个xx文件夹存放图片<br>第二种方式就是在source文件夹，新建images文件夹负责存储所有xx.md文件所有的图片。</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo部署问题</title>
      <link href="/2014/09/21/hexo%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<p>这两天学着使用hexo和github page搭建个人博客<br>到使用hexo deploy自动部署到github page的时候出现了错误：</p><p>FATAL bash: /dev/tty: No such device or address<br>error: failed to execute prompt script (exit code 1)<br>fatal: could not read Username for ‘<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a>‘: Invalid argument<br>Error: bash: /dev/tty: No such device or address<br>error: failed to execute prompt script (exit code 1)<br>fatal: could not read Username for ‘<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a>‘: Invalid argument</p><p><img src="http://img.blog.csdn.net/20170306142722422?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR3JlZW5vdmlh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="此处输入图片的描述"></p><p>在服务器上部署一点问题都没有，但是在本地部署是就一直报这个错误<br>最后把_config.yml中的Git仓库链接改成了ssh链接，然后又给git账户增加了ssh key才解决了问题</p><p>要使用自动部署首先要安装hexo-deployer-git工具：<br>$ npm install hexo-deployer-git –save</p><p>配置_config.yml中的deploy：</p><p>deploy:<br> type: git<br> repo:git@github.com:your_github_user_name/your_github_user_name.github.io.git<br> branch: master</p><p> 注意：这里的repo需要设置成你git仓库的ssh链接</p><p> 生成 ssh key</p><p>命令行中输入：</p><p>$ ssh-keygen -t rsa -C greenovia@qq.com（换成你的邮箱地址）<br>接着出现的一些步骤都可以回车跳过，如下：<br><img src="http://img.blog.csdn.net/20170306142941806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR3JlZW5vdmlh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="此处输入图片的描述"><br>这样在 /c/Users/Administrator/.ssh/id_rsa文件中就生成了公钥</p><p>配置github账户的ssh key</p><p>打开id_rsa.pub文件将一整串公钥拷贝下来</p><p>进入你的github账户设置，在ssh and GPG keys中新增一个ssh key，如下<br><img src="http://img.blog.csdn.net/20170306143047462?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR3JlZW5vdmlh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="此处输入图片的描述"></p><p>把刚刚拷贝出来的公钥粘贴到key中，title放空就好<br><img src="http://img.blog.csdn.net/20170306143103647?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR3JlZW5vdmlh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="此处输入图片的描述"></p><p>验证ssh key：</p><p>$ ssh -T git@github.com</p><p>出现下面的语句说明你的ssh key已经配置好了</p><p>Hi wispyoureyes! You’ve successfully authenticated, but GitHub does not provide shell access.</p><p>初始化本地git仓库</p><p>设置Git的user name和email：</p><p>$ git config –global user.name “wuyanqina”<br>$ git config –global user.email “greenovia@qq.com”（换成你的邮箱地址）</p><p>在本地的hexo init生成的文件夹中初始化git仓库：</p><p>$ git init</p><p>将本地仓库和远程仓库连接（这一步骤可以不做）：</p><p>$ git remote add origin git@github.com:your_github_user_name/your_github_user_name.github.io.git(远程仓库ssh地址) </p><p>做完以上这些步骤，说明你的仓库可以使用ssh方式来上传下载代码，而不需要输入用户名和密码了</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springboot教程</title>
      <link href="/2014/08/16/springboot%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<p><a href="http://412887952-qq-com.iteye.com/blog/2291500" target="_blank" rel="noopener">Spring Boot 系列博客！</a></p>]]></content>
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo Markdown</title>
      <link href="/2014/08/05/index/"/>
      <content type="html"><![CDATA[<p><strong>Markdown语法</strong></p><blockquote><p>1、分段： 两个回车</p><p>2、换行 两个空格 + 回车</p><p>3、标题 # ~ ###### 井号的个数表示几级标题，即Markdown可以表示一级标题到六级标题</p><p>4、引用 &gt;</p><p>5、列表 * ， + ， - ， 1. ，选其中之一，注意后面有个空格</p><p>6、代码区块 四个空格 开头</p><p>7、链接 /<em>*[文字]</em>/(链接地址)</p><p>8、图片 /<em>*![图片说明]</em>/(图片地址) ，图片地址可以是本地路劲，也可以是网络地址</p><p>9、强调 /<strong>文字/</strong> ， /<strong>__*/文字/</strong>_<em><em>/ ， /*</em></em><em>/文字/**_</em>/ ， /<em>文字</em>/</p><p>10、代码 /<strong>```*/，/</strong>``*/</p></blockquote><p><strong>hexo 命令</strong></p><blockquote><p>1.新建 hexo new “my blog”<br>2.编译 hexo generate 或者 hexo g<br>3.开启本地服务 hexo server<br>4.部署 hexo deploy 或者 hexo d<br>5.清除 public hexo clean</p></blockquote>]]></content>
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
